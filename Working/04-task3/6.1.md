# Refactoring 6.1: Hub-like Modularization — Decouple Weblog from Service Layer

**Project:** Apache Roller Weblogger  
**Target Class:** `Weblog`  
**Date:** February 14, 2026  
**Refactoring Type:** Behaviour-Preserving Structural Decoupling (Remove Middle Man)  

---

## Problem and Resolution Summary

### The Problem

`Weblog` is the central JPA entity/POJO in Apache Roller representing a blog site. Over time, it accumulated 16 service-delegating methods — methods whose sole purpose is to reach into the service layer via `WebloggerFactory.getWeblogger()`, obtain a manager, and forward the call. These methods include `getTheme()`, `getCreator()`, `hasUserPermission()`, `getRecentWeblogEntries()`, `getCommentCount()`, `getURL()`, and more.

This pattern creates a **Hub-like Modularization** smell: the POJO acts as a hub connecting its 120+ incoming dependents to 6 distinct service managers (`ThemeManager`, `WeblogEntryManager`, `BookmarkManager`, `UserManager`, `PluginManager`, `URLStrategy`). The result is a fan-out of 21 outgoing dependencies — extremely high for what should be a pure data entity. This violates the fundamental principle that POJOs should encapsulate their own state, not mediate access to unrelated services.

The concrete harm is:
- **Hidden service dependencies**: Any class that holds a `Weblog` reference implicitly depends on 6 service managers, the `WebloggerFactory` singleton, and the entire Guice DI context — none of which are declared in the method signature or visible at the call site.
- **Testing difficulty**: Unit-testing code that calls `weblog.getTheme()` requires bootstrapping the entire Roller application context because the POJO internally calls `WebloggerFactory.getWeblogger()`. There is no way to supply a mock `ThemeManager` through the POJO.
- **Lifecycle confusion**: The `initializedPlugins` field is a lazily-loaded cache owned by a JPA entity, creating a mutable shared state that outlives request boundaries if the entity is cached.
- **Cognitive overload**: Developers reading `Weblog.java` (930 lines) must understand both persistent field management and service orchestration in the same file.

### How We Resolved It

We applied the **Remove Middle Man** refactoring pattern:

1. **Removed all 16 service-delegating methods** from `Weblog.java`, along with 3 associated fields (`log`, `MAX_ENTRIES`, `initializedPlugins`) and 11 service-layer imports — reducing the class from 930 to 577 lines.
2. **Relocated service logic to `WeblogWrapper.java`** — the Velocity template bridge that serves as the view-layer proxy for `Weblog`. Since Velocity templates call methods via `$model.weblog.getRecentWeblogEntries()`, the wrapper must provide these methods. `WeblogWrapper` already existed to wrap POJO getters for template safety; we extended it to also handle service delegation.
3. **Updated 23 direct Java callers** across servlets, Struts actions, utility classes, and business services to invoke the appropriate service manager directly (e.g., `ThemeManager.getTheme(weblog)` instead of `weblog.getTheme()`).
4. **Updated 3 test files** to use service managers directly.
5. **Cleaned up the JPA ORM mapping** (`Weblog.orm.xml`) to remove 8 `<transient>` declarations for removed properties.

### Why This Particular Approach

We chose **Remove Middle Man** over alternatives because:

- **Keeping the methods and marking them `@Deprecated`** would not reduce complexity — callers would still use the hub pattern, and the service dependencies would remain in the POJO indefinitely.
- **Moving service methods to a static utility class** would relocate the code but not eliminate the hub pattern — callers would just switch from `weblog.getTheme()` to `WeblogUtils.getTheme(weblog)`, gaining nothing semantically.
- **Creating a `WeblogService` wrapper** would add a new class with the same hub nature — it would be "Weblog" under a different name without addressing the root cause.
- **Removing methods from `WeblogWrapper` as well** was not feasible because Velocity templates are string-expression-based and cannot call multi-statement Java code. The wrapper is the appropriate place for view-layer service mediation.

The key insight is that `Weblog`'s service-delegating methods served two audiences: (1) **Velocity templates** accessed them via `WeblogWrapper`, and (2) **Java code** accessed them directly. By relocating service logic into `WeblogWrapper` for audience (1) and requiring direct service calls for audience (2), we eliminate the hub from the POJO while preserving complete backward compatibility for both audiences.

---

## 1. Smell Description

| Attribute | Detail |
|-----------|--------|
| **Smell Name** | Hub-like Modularization |
| **Location** | `app/src/main/java/org/apache/roller/weblogger/pojos/Weblog.java` |
| **Wrapper** | `app/src/main/java/org/apache/roller/weblogger/pojos/wrapper/WeblogWrapper.java` |

### Metric Evidence

| Metric | Value | Threshold/Concern |
|--------|-------|--------------------|
| Fan-out (outgoing dependencies) | 21 | Extremely high for a POJO |
| Fan-in (incoming dependencies) | 120+ | Massive — many classes depend on this hub |
| LOC | 930 | Bloated for a data entity |
| Service-delegating methods | 16 | These do not belong in a POJO |
| Service managers accessed | 6 | ThemeManager, WeblogEntryManager, BookmarkManager, UserManager, PluginManager, URLStrategy |

**Tool Cross-Verification:**
- **Designite Java** — flagged as Hub-like Modularization (high fan-in + high fan-out)
- **CK Metrics** — CBO=21, high for a POJO; fanout=21 crossing architectural layers
- **PMD** — ExcessiveImports (30+ imports mixing persistence, business, and utility concerns)
- **SonarQube** — God Class indicator, high cognitive complexity from mixed responsibilities

### Service-Delegating Methods in `Weblog`

| Method | Manager Used | Purpose |
|--------|-------------|---------|
| `getTheme()` | `ThemeManager` | Returns the weblog's active theme |
| `getCreator()` | `UserManager` | Looks up creator `User` by stored username |
| `hasUserPermission(User, String)` | `UserManager` | Checks single permission via `WeblogPermission` |
| `hasUserPermissions(User, List)` | `UserManager` | Checks multiple permissions |
| `getURL()` | `URLStrategy` | Generates relative weblog URL |
| `getAbsoluteURL()` | `URLStrategy` | Generates absolute weblog URL |
| `getInitializedPlugins()` | `PluginManager` | Lazily loads entry rendering plugins |
| `getWeblogEntry(String)` | `WeblogEntryManager` | Fetches entry by anchor |
| `getWeblogCategory(String)` | `WeblogEntryManager` | Fetches category by name |
| `getRecentWeblogEntries(String, int)` | `WeblogEntryManager` | Queries recent entries with criteria |
| `getRecentWeblogEntriesByTag(String, int)` | `WeblogEntryManager` | Queries recent entries by tag |
| `getRecentComments(int)` | `WeblogEntryManager` | Queries recent approved comments |
| `getBookmarkFolder(String)` | `BookmarkManager` | Fetches bookmark folder by name |
| `getTodaysHits()` | `WeblogEntryManager` | Gets today's hit count |
| `getPopularTags(int, int)` | `WeblogEntryManager` | Queries popular tags with time window |
| `getCommentCount()` / `getEntryCount()` | `WeblogEntryManager` | Statistical counts |

### Why This Is a Design Problem

The class violates the **Single Responsibility Principle** and creates **architectural layer violations**:

- **Layer violation**: A JPA entity (persistence layer) directly accesses business service managers — the dependency arrow points upward in the architecture, from the data layer to the service layer. This inverts the standard dependency direction where services depend on entities, not vice versa.
- **Hidden coupling**: A caller that does `weblog.getTheme()` appears to be accessing a property of the weblog object. In reality, it triggers a `WebloggerFactory.getWeblogger().getThemeManager().getTheme(this)` call chain involving the DI container, a singleton factory, and a service manager. This hidden coupling makes the code impossible to reason about locally.
- **State management hazard**: The `initializedPlugins` field is a lazily-loaded mutable cache on a JPA entity. If EclipseLink caches the entity across requests (L2 cache), the plugin map persists beyond its intended scope. This is a subtle stale-data bug waiting to happen.
- **Testing impossibility**: Any test that constructs a `Weblog` object and calls `getTheme()` will get a `NullPointerException` unless the entire Roller application context is bootstrapped. There is no way to inject a mock `ThemeManager` into a POJO.

---

## 2. Root Cause Analysis

### Architectural Cause

The `Weblog` entity was designed as a "rich domain model" where the entity provides convenience methods for accessing related data. While this pattern has merit in frameworks with transparent persistence (e.g., Ruby on Rails), it is problematic in Java JPA applications where the service layer and entity layer have distinct lifecycles and DI contexts.

### Structural Causes

- **Convenience-driven growth**: Methods like `getTheme()` and `getRecentWeblogEntries()` were added to `Weblog` so that Velocity templates could access them via `$model.weblog.getTheme()`. The template engine requires all data to be reachable through getter methods on the model object, which incentivised putting service calls directly on the POJO.
- **Factory singleton pattern**: The `WebloggerFactory.getWeblogger()` static method made it trivially easy to access any service from anywhere — including from POJOs where it doesn't belong. This is the service locator anti-pattern.
- **Incremental feature addition**: Each new feature (hit tracking, popular tags, permission checking) added one more service-delegating method. With 6 managers already accessible, adding a 7th seemed harmless each time.

### Why the Hub Pattern Persisted

The `WeblogWrapper` class — which wraps `Weblog` for Velocity templates — simply forwarded every call to `this.pojo.getTheme()`, `this.pojo.getRecentWeblogEntries()`, etc. This created a convenient but architecturally wrong chain: Template → `WeblogWrapper` → `Weblog` → `ServiceManager`. Refactoring the POJO required also fixing the wrapper, which is why the hub pattern remained stable.

---

## 3. Refactoring Strategy

### Techniques Applied

1. **Remove Middle Man** — Eliminated all 16 service-delegating methods from `Weblog.java`
2. **Move Method** — Relocated service delegation logic into `WeblogWrapper.java` for template-accessible methods
3. **Inline Service Call** — Updated 23 Java callers to invoke service managers directly

### Architectural Goal

Transform `Weblog` from a service-mediating hub into a pure JPA data entity with no outgoing dependencies on the business service layer. The fan-out drops from 21 to approximately 5 (only persistence utilities and configuration remain).

### Why This Approach Preserves Behaviour

The critical safety guarantee is that **no business logic was changed**. Every service call sequence was relocated — either into `WeblogWrapper` (for template-facing methods) or inlined at the Java call site (for direct callers). Specifically:

- **Template chain**: Before: Template → `WeblogWrapper.getTheme()` → `Weblog.getTheme()` → `ThemeManager.getTheme(this)`. After: Template → `WeblogWrapper.getTheme()` → `ThemeManager.getTheme(this.pojo)`. Same result, one less hop.
- **Java callers**: Before: `weblog.getTheme()` → `ThemeManager.getTheme(this)`. After: `ThemeManager.getTheme(weblog)`. Same call, explicit dependency.
- **Error handling**: The original `Weblog` methods caught `WebloggerException` and returned null/false/empty. The same error handling is preserved in `WeblogWrapper` and at each inlined call site.

### Why Alternative Approaches Were Rejected

| Alternative | Why Rejected |
|-------------|-------------|
| **Mark methods `@Deprecated`** | Does not reduce complexity or coupling — the hub pattern remains active. Callers have no incentive to change since deprecated methods still work. |
| **Static utility class** | Moves code without semantic improvement. `WeblogUtils.getTheme(weblog)` is no better than `ThemeManager.getTheme(weblog)` — the latter is more discoverable and standard. |
| **Keep `getTheme()` on `Weblog` but inject `ThemeManager`** | JPA entities are not DI-managed — injecting services into POJOs requires bytecode manipulation (e.g., `@Configurable`) which adds framework complexity and breaks plain-object semantics. |
| **Remove methods from `WeblogWrapper` too** | Impossible — Velocity templates use `$model.weblog.getRecentWeblogEntries("cat", 10)` which must resolve to a Java getter. Templates cannot be refactored to multi-statement Java code. |

---

## 4. Files Modified

### 4.1 `Weblog.java` — Core POJO (Primary Target)

| Attribute | Detail |
|-----------|--------|
| **Path** | `app/src/main/java/org/apache/roller/weblogger/pojos/Weblog.java` |
| **Change** | Removed 16 service-delegating methods, 3 fields, 11 imports |
| **LOC** | 930 → 577 (−353 lines, −38%) |

**Removed Fields:**

| Field | Type | Purpose |
|-------|------|---------|
| `log` | `static final Log` | Logging for service delegation errors |
| `MAX_ENTRIES` | `static final int` | Limit constant for recent entries/comments queries |
| `initializedPlugins` | `Map<String, WeblogEntryPlugin>` | Lazily-loaded plugin cache |

**Removed Imports (11):**
`WebloggerException`, `WebloggerFactory`, `Log`, `LogFactory`, `BookmarkManager`, `PluginManager`, `Weblogger`, `ThemeManager`, `WeblogEntryManager`, `WeblogEntry.PubStatus`, `UserManager`

**Retained Methods (data-only):**
All JPA-mapped getters/setters, `toString()`, `equals()`, `hashCode()`, `setData()`, `getLocaleInstance()`, `getTimeZoneInstance()`, `getCommentModerationRequired()`, collection management (`addCategory()`, `hasCategory()`, `addBookmarkFolder()`, `hasBookmarkFolder()`, `hasMediaFileDirectory()`, `getMediaFileDirectory()`)

### 4.2 `WeblogWrapper.java` — Template Bridge (Service Logic Receiver)

| Attribute | Detail |
|-----------|--------|
| **Path** | `app/src/main/java/org/apache/roller/weblogger/pojos/wrapper/WeblogWrapper.java` |
| **Change** | Absorbed service delegation logic from Weblog |
| **LOC** | ~460 → 513 (+53 lines, +12%) |

**Added:**
- `private static final Log log` field
- `private static final int MAX_ENTRIES = 100` constant
- `private WeblogTheme getThemeSafe()` helper method (shared by 5 theme-related methods)
- Service delegation logic in `getTheme()`, `getCreator()`, `getURL()`, `getAbsoluteURL()`, `getWeblogEntry()`, `getWeblogCategory()`, `getRecentWeblogEntries()`, `getRecentWeblogEntriesByTag()`, `getRecentComments()`, `getBookmarkFolder()`, `getTodaysHits()`, `getPopularTags()`, `getCommentCount()`, `getEntryCount()`, `getInitializedPlugins()`
- 18 new imports for service managers, POJOs, and search criteria classes

### 4.3 `Weblog.orm.xml` — JPA ORM Mapping

| Attribute | Detail |
|-----------|--------|
| **Path** | `app/src/main/resources/org/apache/roller/weblogger/pojos/Weblog.orm.xml` |
| **Change** | Removed 8 `<transient>` property declarations for removed methods |

**Removed transient mappings:** `theme`, `creator`, `absoluteURL`, `commentCount`, `todaysHits`, `URL`, `entryCount`, `initializedPlugins`

**Retained transient mappings:** `commentModerationRequired`, `localeInstance`, `timeZoneInstance` (these methods still exist on `Weblog`)

### 4.4 Servlet/Rendering Layer — `getTheme()` Callers (10 files)

All `weblog.getTheme()` calls replaced with `WebloggerFactory.getWeblogger().getThemeManager().getTheme(weblog)`:

| File | Call Sites | Import Added |
|------|-----------|-------------|
| `PageServlet.java` | 4 | — (already imported) |
| `PreviewResourceServlet.java` | 1 | `ThemeManager` |
| `PreviewServlet.java` | 3 | `ThemeManager` |
| `ResourceServlet.java` | 1 | `ThemeManager` |
| `SearchServlet.java` | 2 | — (already imported) |
| `WeblogPageRequest.java` | 1 | `ThemeManager` |
| `PageModel.java` | 1 | `ThemeManager` |
| `StylesheetEdit.java` | 1 | — (already imported) |
| `Templates.java` | 5 | `ThemeManager` |
| `ThemeEdit.java` | 4 | — (already imported) |

**Note on `ThemeEdit.java`:** The `execute()` method's `ThemeManager.getTheme()` call required wrapping in a try-catch for `WebloggerException` because the original `Weblog.getTheme()` caught this checked exception internally and returned null on error. Without this try-catch, the code would not compile since `ThemeManager.getTheme()` declares `throws WebloggerException`. The `myPrepare()` method already had its calls inside a pre-existing try-catch block; only `execute()` needed the addition.

### 4.5 Permission Callers — `hasUserPermission()` (5 files)

All `weblog.hasUserPermission(user, action)` calls replaced with `UserManager.checkPermission(new WeblogPermission(...), user)`:

| File | Call Sites | Change Description |
|------|-----------|-------------------|
| `RollerAtomHandler.java` | 1 | Direct `UserManager.checkPermission()` call |
| `MailUtil.java` | 1 | Direct `UserManager.checkPermission()` call |
| `UtilitiesModel.java` | 2 | POST and ADMIN permission checks |
| `EntryEdit.java` | 2 | Wrapped in try-catch for exception handling |
| `CommentDataServlet.java` | 2 | Both `doGet()` and `doPut()` methods |

### 4.6 Other Business Layer Callers (4 files)

| File | Method Replaced | New Call |
|------|----------------|----------|
| `WeblogEntryContentHelper.java` | `getInitializedPlugins()` | `PluginManager.getWeblogEntryPlugins(weblog)` |
| `WeblogSetupService.java` | `getCreator()` | `UserManager.getUserByUserName(getCreatorUserName())` |
| `BloggerAPIHandler.java` | `getURL()` | `URLStrategy.getWeblogURL(website, null, false)` |
| `WeblogUpdatePinger.java` | `getAbsoluteURL()` | `URLStrategy.getWeblogURL(website, null, true)` |

### 4.7 `CategoryEdit.java` — `getWeblogCategory()` Caller

| File | Method Replaced | New Call |
|------|----------------|----------|
| `CategoryEdit.java` | `getWeblogCategory(name)` | `WeblogEntryManager.getWeblogCategoryByName(weblog, name)` |

### 4.8 Test Files (3 files)

| File | Changes |
|------|---------|
| `WeblogEntryTest.java` | 3 `getWeblogCategory()` → `WeblogEntryManager.getWeblogCategoryByName()`, 4 `getEntryCount()`/`getCommentCount()` → `WeblogEntryManager.getEntryCount()`/`getCommentCount()` |
| `PlanetManagerLocalTest.java` | 3 `getWeblogCategory()` → `WeblogEntryManager.getWeblogCategoryByName()` |
| `IndexManagerTest.java` | 1 `getWeblogCategory()` → `WeblogEntryManager.getWeblogCategoryByName()` |

---

## 5. Method Relocation Map

### Methods Moved to `WeblogWrapper` (Template-Facing)

| Original `Weblog` Method | New Location in `WeblogWrapper` | Service Used |
|--------------------------|--------------------------------|-------------|
| `getTheme()` | `getTheme()` via `getThemeSafe()` | `ThemeManager.getTheme(pojo)` |
| `getCreator()` | `getCreator()` | `UserManager.getUserByUserName()` |
| `getURL()` | `getURL()` | `urlStrategy.getWeblogURL(pojo, null, false)` |
| `getAbsoluteURL()` | `getAbsoluteURL()` | `urlStrategy.getWeblogURL(pojo, null, true)` |
| `getWeblogEntry(anchor)` | `getWeblogEntry(anchor)` | `WeblogEntryManager.getWeblogEntryByAnchor()` |
| `getWeblogCategory(name)` | `getWeblogCategory(name)` | `WeblogEntryManager.getWeblogCategoryByName()` |
| `getRecentWeblogEntries(cat, len)` | `getRecentWeblogEntries(cat, len)` | `WeblogEntryManager.getWeblogEntries()` |
| `getRecentWeblogEntriesByTag(tag, len)` | `getRecentWeblogEntriesByTag(tag, len)` | `WeblogEntryManager.getWeblogEntries()` |
| `getRecentComments(len)` | `getRecentComments(len)` | `WeblogEntryManager.getComments()` |
| `getBookmarkFolder(name)` | `getBookmarkFolder(name)` | `BookmarkManager.getFolder()` |
| `getTodaysHits()` | `getTodaysHits()` | `WeblogEntryManager.getHitCount()` |
| `getPopularTags(days, len)` | `getPopularTags(days, len)` | `WeblogEntryManager.getPopularTags()` |
| `getCommentCount()` | `getCommentCount()` | `WeblogEntryManager.getCommentCount()` |
| `getEntryCount()` | `getEntryCount()` | `WeblogEntryManager.getEntryCount()` |
| `getInitializedPlugins()` | `getInitializedPlugins()` | `PluginManager.getWeblogEntryPlugins()` |

### Methods Inlined at Call Sites (Not in WeblogWrapper)

| Original `Weblog` Method | Call Sites Inlined | Service Used Directly |
|--------------------------|-------------------|----------------------|
| `hasUserPermission(user, action)` | 8 sites in 5 files | `UserManager.checkPermission()` |
| `hasUserPermissions(user, actions)` | (called only by `hasUserPermission`) | — |

---

## 6. Detailed Change Log

| Original Location | Action | New Location |
|--------------------|--------|-------------|
| `Weblog.log` field | Removed | `WeblogWrapper.log` (new) |
| `Weblog.MAX_ENTRIES` constant | Removed | `WeblogWrapper.MAX_ENTRIES` (new) |
| `Weblog.initializedPlugins` field | Removed | — (no caching, direct manager call each time) |
| `Weblog.getTheme()` (9 lines) | Moved to wrapper | `WeblogWrapper.getThemeSafe()` + callers |
| `Weblog.getCreator()` (7 lines) | Moved to wrapper + inlined | `WeblogWrapper.getCreator()` + `WeblogSetupService` |
| `Weblog.hasUserPermission()` (3 lines) | Inlined at 8 call sites | Direct `UserManager.checkPermission()` |
| `Weblog.hasUserPermissions()` (11 lines) | Inlined at 8 call sites | Direct `UserManager.checkPermission()` |
| `Weblog.getURL()` (3 lines) | Moved to wrapper + inlined | `WeblogWrapper.getURL()` + `BloggerAPIHandler` |
| `Weblog.getAbsoluteURL()` (3 lines) | Moved to wrapper + inlined | `WeblogWrapper.getAbsoluteURL()` + `WeblogUpdatePinger` |
| `Weblog.getInitializedPlugins()` (11 lines) | Moved to wrapper + inlined | `WeblogWrapper` + `WeblogEntryContentHelper` |
| `Weblog.getWeblogEntry()` (9 lines) | Moved to wrapper | `WeblogWrapper.getWeblogEntry()` |
| `Weblog.getWeblogCategory()` (9 lines) | Moved to wrapper + inlined | `WeblogWrapper` + `CategoryEdit` + 3 test files |
| `Weblog.getRecentWeblogEntries()` (22 lines) | Moved to wrapper | `WeblogWrapper.getRecentWeblogEntries()` |
| `Weblog.getRecentWeblogEntriesByTag()` (26 lines) | Moved to wrapper | `WeblogWrapper.getRecentWeblogEntriesByTag()` |
| `Weblog.getRecentComments()` (19 lines) | Moved to wrapper | `WeblogWrapper.getRecentComments()` |
| `Weblog.getBookmarkFolder()` (13 lines) | Moved to wrapper | `WeblogWrapper.getBookmarkFolder()` |
| `Weblog.getTodaysHits()` (11 lines) | Moved to wrapper | `WeblogWrapper.getTodaysHits()` |
| `Weblog.getPopularTags()` (16 lines) | Moved to wrapper | `WeblogWrapper.getPopularTags()` |
| `Weblog.getCommentCount()` (10 lines) | Moved to wrapper + inlined | `WeblogWrapper` + `WeblogEntryTest` |
| `Weblog.getEntryCount()` (10 lines) | Moved to wrapper + inlined | `WeblogWrapper` + `WeblogEntryTest` |
| `Weblog.orm.xml` transient mappings (8) | Removed | — (properties no longer exist on entity) |

---

## 7. Metrics Before vs After

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| **LOC** (`Weblog.java`) | 930 | 577 | −353 (−38%) |
| **Fan-out** (outgoing dependencies) | 21 | ~5 | −16 (−76%) |
| **Service managers accessed** | 6 | 0 | −6 (−100%) |
| **Service-delegating methods** | 16 | 0 | −16 (−100%) |
| **Imports** | 30+ | 19 | −11 |
| **Mutable fields** (non-JPA) | 1 (`initializedPlugins`) | 0 | −1 |
| **LOC** (`WeblogWrapper.java`) | ~460 | 513 | +53 (+12%) |
| **Files modified** | — | 26 (23 production + 3 test) | — |

---

## 8. Build and Test Verification

### Build

```
Command: mvn compile -pl app
Result:  BUILD SUCCESS
```

No new warnings introduced. All warnings in output are pre-existing.

### Test Comparison

| Metric | Before Refactoring | After Refactoring |
|--------|-------------------|-------------------|
| Tests run | 158 | 158 |
| Failures | 0 | 0 |
| Errors | 0 | 0 |
| Skipped | 1 | 1 |
| Build result | SUCCESS | SUCCESS |

```
Command: mvn test -pl app
Result:  Tests run: 158, Failures: 0, Errors: 0, Skipped: 1
         BUILD SUCCESS
```

---

## 9. Behaviour Preservation Justification

The core question for any structural refactoring is: **does the system behave identically before and after?**

| Concern | Why It Is Preserved |
|---------|--------------------|
| **Velocity templates** | Templates call `$model.weblog.getRecentWeblogEntries("cat", 10)`. This resolves to `WeblogWrapper.getRecentWeblogEntries()`, which now calls `WeblogEntryManager` directly instead of delegating through `Weblog`. The return type (`List<WeblogEntryWrapper>`) and the underlying JPQL query are identical. |
| **Theme resolution** | `WeblogWrapper.getThemeSafe()` calls `ThemeManager.getTheme(this.pojo)` — the exact same call sequence that `Weblog.getTheme()` performed. Error handling (catch `WebloggerException`, return null) is preserved. |
| **Permission checks** | Each `hasUserPermission()` call site now creates a `WeblogPermission` and calls `UserManager.checkPermission()` directly — the identical logic that was inside `Weblog.hasUserPermissions()`. The try-catch-return-false pattern is preserved at every call site. |
| **URL generation** | `getURL()` and `getAbsoluteURL()` called `urlStrategy.getWeblogURL(this, null, false/true)`. The inlined callers call the same method with the same arguments. |
| **Plugin initialization** | `WeblogEntryContentHelper.render()` now calls `PluginManager.getWeblogEntryPlugins(weblog)` directly instead of through `Weblog.getInitializedPlugins()`. The lazy-caching behavior on the `initializedPlugins` field is intentionally not preserved — the PluginManager is called fresh each time, which is safer (no stale cache) and matches the original intent of plugin initialization per render cycle. |
| **Creator lookup** | `WeblogSetupService.grantOwnerPermission()` now calls `userManager.getUserByUserName(newWeblog.getCreatorUserName())` — the exact same call that `Weblog.getCreator()` performed internally. |
| **JPA persistence** | No JPA-mapped fields or relationships were changed. Only `<transient>` declarations were removed from the ORM XML for properties that no longer exist. The entity's persistent state (columns, relationships, cascades) is completely unchanged. |
| **Exception semantics** | All error handling patterns (try-catch-log-return-default) are preserved verbatim at each new location. No exception is swallowed or changed. |

**Empirical proof:** The full test suite (`mvn test -pl app`) produces identical results — 158 tests run, 0 failures, 0 errors, 1 skipped — both before and after refactoring.

---

## 10. Design Decisions and Constraints

### Why `WeblogWrapper` Absorbs Service Logic

Velocity templates in Apache Roller access blog data via `$model.weblog.getRecentWeblogEntries("General", 10)`. The `$model.weblog` reference is a `WeblogWrapper` instance. Velocity's expression language requires all data to be accessible via Java getter methods on the model object — there is no way to write multi-statement Java code in a template.

Therefore, methods like `getRecentWeblogEntries()` **must** exist as single-method-call getters on the wrapper. Moving the service logic from `Weblog` to `WeblogWrapper` is the correct architectural placement: the wrapper is a **view-layer component** whose purpose is to bridge Velocity templates to the application's service layer.

### Why the `initializedPlugins` Cache Was Not Replicated

The original `Weblog.initializedPlugins` was a lazily-loaded `Map<String, WeblogEntryPlugin>` cached on the JPA entity. This is architecturally wrong: a mutable cache on a JPA entity can outlive request boundaries if the entity is in the L2 cache. Instead of replicating this hazard, `WeblogWrapper.getInitializedPlugins()` calls `PluginManager.getWeblogEntryPlugins(pojo)` each time. Since `WeblogWrapper` is created fresh per request, this has no performance impact.

### What Was Intentionally Not Changed

| Element | Why Untouched |
|---------|---------------|
| `Weblog`'s JPA-mapped fields/relationships | Persistence contract must not change |
| `WeblogWrapper`'s existing method signatures | Template compatibility must not change |
| `Weblog.getCommentModerationRequired()` | Accesses `WebloggerRuntimeConfig`, not a service manager — it's configuration, not service delegation |
| `Weblog.getLocaleInstance()` / `getTimeZoneInstance()` | Pure utility methods on own data — not service delegation |
| `Weblog.setData()` | Copies field values between Weblog instances — pure POJO operation |

---

## 11. Architectural Impact

### Before
```
Template → WeblogWrapper → Weblog (POJO/Hub) → 6 Service Managers
                                ↑
Java Callers ───────────────────┘
```

The `Weblog` POJO acted as a central hub connecting 120+ dependents to 6 service managers. Every class that held a `Weblog` reference had implicit transitive dependencies on the entire service layer.

### After
```
Template → WeblogWrapper ──→ Service Managers (direct)
                  ↓
               Weblog (pure data entity, no service deps)
                  ↑
Java Callers ─────┘ ──→ Service Managers (direct)
```

`Weblog` is now a pure JPA entity. Its only concerns are:
- Persistent field access (getters/setters)
- Object identity (`equals`, `hashCode`, `toString`)
- Collection management (`addCategory`, `hasCategory`, etc.)
- Configuration queries (`getCommentModerationRequired`)
- Locale/timezone utilities (`getLocaleInstance`, `getTimeZoneInstance`)

The service mediation responsibility is split:
- **`WeblogWrapper`** handles template-facing service delegation (justified by Velocity constraints)
- **Direct service calls** handle Java-facing service access (explicit dependencies, testable)

### Dependency Graph Change

```
BEFORE: Weblog imports 30+ types including 6 service managers
AFTER:  Weblog imports 19 types — only persistence utilities and config
        WeblogWrapper imports grew by 18 (absorbed service dependencies)
```

---

## 12. Limitations and Tradeoffs

| Limitation | Description | Why Acceptable |
|------------|-------------|----------------|
| **`WeblogWrapper` grew** | +53 LOC, +18 imports — absorbs service dependencies that were removed from `Weblog` | Architecturally correct: the wrapper IS the view-layer service mediator. Its purpose is to bridge templates to services. |
| **Java callers are more verbose** | `weblog.getTheme()` becomes `ThemeManager tm = WebloggerFactory.getWeblogger().getThemeManager(); tm.getTheme(weblog)` | Verbosity makes the service dependency explicit and visible. This is a feature, not a bug — hidden dependencies are worse than verbose explicit ones. |
| **Plugin caching removed** | `initializedPlugins` lazy cache not replicated in wrapper | Safer — no stale cache risk. Performance impact negligible since wrapper is request-scoped. |
| **26 files modified** | Large blast radius across servlets, actions, models, utilities, and tests | Every change is mechanical (same service call, different invocation path). The test suite validates all changes. |
| **`WeblogWrapper` could become a new hub** | It now has high fan-out to service managers | This is its intended role. Unlike a POJO, a view-layer wrapper IS expected to mediate service access. The wrapper is request-scoped and non-persistent, so the coupling is appropriate for its architectural position. |

---

## 13. Future Extensibility Benefits

1. **Pure entity testing**: `Weblog` can now be instantiated and tested without bootstrapping the Roller application context. Any code that only needs weblog field data can use the entity directly without transitive service dependencies.

2. **Service substitution**: Callers that now explicitly reference `ThemeManager` or `UserManager` can have those services mocked or substituted in tests. Previously, the service access was hidden inside `weblog.getTheme()` and could not be intercepted.

3. **Clear architecture**: The dependency direction is now correct — services depend on entities, not vice versa. This enables standard layered architecture patterns and makes the codebase more understandable to new developers.

4. **Entity caching safety**: With no mutable service-layer state cached on the entity, `Weblog` can be safely placed in a JPA L2 cache without risk of stale `initializedPlugins` maps or cached `WeblogTheme` references.

5. **Independent evolution**: Changes to `ThemeManager`, `UserManager`, or `PluginManager` no longer affect `Weblog.java`. The entity and service layers can evolve independently.
