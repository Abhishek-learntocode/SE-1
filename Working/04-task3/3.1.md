# Refactoring 3.1: Feature Envy — Extract Tag Aggregate Persistence

**Project:** Apache Roller Weblogger  
**Target Class:** `JPAWeblogEntryManagerImpl`  
**Target Method:** `updateTagCount()`  
**Date:** February 14, 2026  
**Refactoring Type:** Behaviour-Preserving Structural Extraction  

---

## Problem and Resolution Summary

### The Problem

The private method `updateTagCount(String name, Weblog website, int amount)` in `JPAWeblogEntryManagerImpl` (originally lines 1046–1110) is a textbook case of **Feature Envy**: it accesses only `JPAPersistenceStrategy` members — calling `strategy.getNamedQuery()`, `strategy.store()`, `strategy.getNamedUpdate()`, and `Query.executeUpdate()` — and does not access any field or method belonging to its own class (`JPAWeblogEntryManagerImpl`). The entire method body is exclusively concerned with querying, creating, updating, and deleting `WeblogEntryTagAggregate` entities through the persistence strategy.

A closely related private method, `removeWeblogEntryTag(WeblogEntryTag tag)`, exhibits the same pattern: it calls `updateTagCount()` (which is all persistence strategy calls) and then `this.strategy.remove(tag)` — again, only touching `JPAPersistenceStrategy` state.

The concrete harm is:
- **Misplaced responsibility**: Tag aggregate persistence logic lives inside a class whose primary responsibility is weblog entry management, inflating the class's WMC (197) and CBO (30)
- **Cognitive complexity**: The `updateTagCount()` method has a cognitive complexity of 12 (SonarQube S3776) — it manages two parallel query/create/update paths (weblog-specific and site-wide aggregates), plus a cleanup query. This complexity belongs with the persistence layer operating on `WeblogEntryTagAggregate`, not inside a business manager for `WeblogEntry`
- **Testing difficulty**: Tag aggregate logic cannot be independently tested because it is a `private` method inside a large class with many unrelated dependencies
- **Coupling inflation**: `JPAWeblogEntryManagerImpl` imports `WeblogEntryTagAggregate` solely for this method — removing the method eliminates this coupling

### How We Resolved It

We extracted the tag aggregate persistence logic into a dedicated `WeblogTagRepository` class:

1. Created `WeblogTagRepository` — a new `@Singleton` class in `weblogger.business.jpa` that encapsulates both `updateTagCount()` and `removeWeblogEntryTag()`
2. The method bodies were moved **verbatim** — zero logic changes
3. `JPAWeblogEntryManagerImpl` now delegates all tag aggregate operations to the injected `WeblogTagRepository`
4. Registered the new class in the Guice dependency injection module

### Why This Particular Approach

We chose **Extract Class + Delegation** because:

- **Moving to the data's owner**: The methods operate entirely on `JPAPersistenceStrategy` and `WeblogEntryTagAggregate` data — moving them to a dedicated repository class aligns responsibility with data ownership
- **Preserving encapsulation**: The calling code in `saveWeblogEntry()` and `removeWeblogEntry()` only needs to call `weblogTagRepository.updateTagCount(...)` and `weblogTagRepository.removeWeblogEntryTag(...)` — the iteration logic over tags stays in the caller where it belongs (the caller knows about entry publication state and tag sets)
- **No public API change**: `updateTagCount()` and `removeWeblogEntryTag()` were both `private` methods — no external caller is affected
- **Transaction safety**: The new class receives the same `JPAPersistenceStrategy` singleton, so it shares the same JPA EntityManager and transaction context — no boundary changes

---

## 1. Smell Description

| Attribute | Detail |
|-----------|--------|
| **Smell Name** | Feature Envy |
| **Location** | `app/src/main/java/org/apache/roller/weblogger/business/jpa/JPAWeblogEntryManagerImpl.java` |
| **Method** | `updateTagCount(String name, Weblog website, int amount)` |
| **Envied Class** | `JPAPersistenceStrategy` |

### Metric Evidence

| Metric | Value | Concern |
|--------|-------|---------|
| WMC (`JPAWeblogEntryManagerImpl`) | 197 | Extremely high for a single class |
| CBO (`JPAWeblogEntryManagerImpl`) | 30 | High coupling to external types |
| Cognitive Complexity (`updateTagCount`) | 12 | Exceeds recommended threshold of 7-10 |
| LOC (`JPAWeblogEntryManagerImpl`) | 1297 | Bloated class |

**Tool Cross-Verification:**
- **Designite Java** — Flagged as Feature Envy: "`updateTagCount` is more interested in members of the type: `JPAPersistenceStrategy`"
- **SonarQube** — Rule S3776: Cognitive Complexity of `updateTagCount()` is 12 (exceeds threshold)
- **CK Metrics** — WMC=197, CBO=30 on `JPAWeblogEntryManagerImpl`

### Feature Envy Pattern in `updateTagCount()`

The method makes the following external calls:

| Call | Target | Count | Purpose |
|------|--------|-------|---------|
| `strategy.getNamedQuery(...)` | `JPAPersistenceStrategy` | 2 | Query weblog-specific and site-wide tag aggregates |
| `strategy.store(...)` | `JPAPersistenceStrategy` | up to 4 | Create or update tag aggregate rows |
| `strategy.getNamedUpdate(...)` | `JPAPersistenceStrategy` | 1 | Get cleanup query for zero-count rows |
| `Query.executeUpdate()` | `Query` (from strategy) | 1 | Execute cleanup |

Internal calls to `JPAWeblogEntryManagerImpl` own state: **zero**. The method does not access `this.roller`, `this.entryAnchorToIdMap`, or any other field of its own class.

### Feature Envy Pattern in `removeWeblogEntryTag()`

| Call | Target | Count |
|------|--------|-------|
| `updateTagCount(...)` | Self (but all persistence calls) | 1 |
| `this.strategy.remove(tag)` | `JPAPersistenceStrategy` | 1 |

Both methods are entirely oriented toward persistence operations on `WeblogEntryTagAggregate` entities through `JPAPersistenceStrategy`.

---

## 2. Root Cause Analysis

### Architectural Cause

`JPAWeblogEntryManagerImpl` was designed as a single class implementing the monolithic `WeblogEntryManager` interface, which covers entry CRUD, comments, categories, tags, and statistics. Tag aggregate maintenance was implemented as private helper methods because they are called during entry save/remove operations. Over time, this created a situation where the tag persistence logic lives inside the entry manager purely for historical convenience, not because it belongs there.

### Why the Method Enviess `JPAPersistenceStrategy`

The `updateTagCount()` method performs a complete persistence workflow:
1. **Query** — fetch existing `WeblogEntryTagAggregate` for (tag, weblog) and (tag, null)
2. **Create or Update** — increment/decrement counts, set `lastUsed` timestamp
3. **Cleanup** — delete aggregate rows where count has dropped to zero

Every step involves `JPAPersistenceStrategy` operations. The method's entire purpose is to maintain `WeblogEntryTagAggregate` entities — a persistence concern, not an entry management concern. It was placed here only because `saveWeblogEntry()` needs to call it, but that is a **coordination dependency** (entry saving triggers tag count updates), not a reason to colocate the implementation.

---

## 3. Refactoring Strategy

### Techniques Applied

1. **Extract Class** — Created `WeblogTagRepository` containing `updateTagCount()` and `removeWeblogEntryTag()`, moved verbatim
2. **Introduce Dependency** — Added `WeblogTagRepository` as constructor-injected dependency in `JPAWeblogEntryManagerImpl`
3. **Replace Direct Calls with Delegation** — All 4 callsites in `saveWeblogEntry()` and `removeWeblogEntry()` now delegate to the repository

### Architectural Goal

Move tag aggregate persistence to a class whose single responsibility is managing `WeblogEntryTagAggregate` entities, thereby:
- Reducing the Feature Envy smell (method now lives with the data it operates on)
- Reducing CBO of `JPAWeblogEntryManagerImpl` (no longer imports `WeblogEntryTagAggregate`)
- Enabling independent testing of tag aggregate logic

### Why This Approach Preserves Behaviour

1. **Same persistence strategy**: `WeblogTagRepository` receives the same `JPAPersistenceStrategy` singleton via Guice injection. The thread-local `EntityManager` is shared across all classes in the same request, so `updateTagCount()` operates against the identical JPA persistence context as before.

2. **Same transaction scope**: No new transaction demarcation (`@Transactional`, manual `begin`/`commit`) was introduced. Tag count updates still execute within the same transaction as `saveWeblogEntry()` or `removeWeblogEntry()`.

3. **Verbatim code transfer**: Every line of `updateTagCount()` and `removeWeblogEntryTag()` was moved character-for-character. No query strings, parameter bindings, conditional branches, or entity lifecycle operations were modified.

4. **Private method extraction**: Both methods were `private` — no external class called them directly. The only callers are `saveWeblogEntry()` and `removeWeblogEntry()`, which now call `weblogTagRepository.updateTagCount(...)` and `weblogTagRepository.removeWeblogEntryTag(...)` instead — producing identical behavior.

5. **Execution ordering preserved**: The tag aggregation calls occur at exactly the same points in `saveWeblogEntry()` (before `strategy.store(entry)`) and `removeWeblogEntry()` (before `strategy.remove(entry)`).

### Why Alternative Approaches Were Rejected

| Alternative | Why Rejected |
|-------------|-------------|
| **Create an interface for the repository** | `WeblogTagRepository` is an internal implementation detail, not a public API contract. An interface would add unnecessary abstraction for a class with a single consumer. If future needs arise (e.g., caching decorator), an interface can be introduced then. |
| **Move methods to `JPAPersistenceStrategy`** | `JPAPersistenceStrategy` is a generic persistence utility — it should not contain domain-specific tag aggregation logic. That would move the Feature Envy to a different class, not resolve it. |
| **Keep methods in class but refactor internally** | This would not resolve the Feature Envy smell — the method would still be more interested in `JPAPersistenceStrategy` than in its own class. The fundamental problem is misplaced responsibility, not code complexity. |
| **Merge into the existing `CommentManager` extraction** | Tags and comments are different domains. Combining them would create a new cohesion problem. |

---

## 4. Files Created

### 4.1 `WeblogTagRepository.java`

| Attribute | Detail |
|-----------|--------|
| **Path** | `app/src/main/java/org/apache/roller/weblogger/business/jpa/WeblogTagRepository.java` |
| **Purpose** | Repository for tag aggregate persistence operations |
| **Package** | `org.apache.roller.weblogger.business.jpa` |
| **Annotation** | `@com.google.inject.Singleton` |
| **LOC** | 138 |

**Constructor Dependencies (Guice-injected):**

| Dependency | Type | Purpose |
|------------|------|---------|
| `strategy` | `JPAPersistenceStrategy` | JPA persistence operations (`getNamedQuery`, `store`, `remove`, `getNamedUpdate`) |

**Methods:**

| Method | Visibility | Return Type | Description |
|--------|-----------|-------------|-------------|
| `updateTagCount(String, Weblog, int)` | `public` | `void` | Maintains tag aggregate table — creates, increments, decrements, and cleans up `WeblogEntryTagAggregate` rows |
| `removeWeblogEntryTag(WeblogEntryTag)` | `public` | `void` | Removes a tag, decrementing aggregates if the entry is published |

**Key Implementation Details:**
- `updateTagCount()` operates on exactly two rows per invocation: one for (tag, weblog) and one for (tag, null/site-wide)
- Creates new aggregate rows on first-time positive increment
- Deletes rows where count drops to ≤ 0 via a named update query
- `removeWeblogEntryTag()` conditionally calls `updateTagCount()` (only if entry is published) then removes the `WeblogEntryTag` entity

---

## 5. Files Modified

### 5.1 `JPAWeblogEntryManagerImpl.java`

| Change | Detail |
|--------|--------|
| **Added field** | `private final WeblogTagRepository weblogTagRepository` |
| **Modified constructor** | Added `WeblogTagRepository weblogTagRepository` parameter (Guice-injected) |
| **Updated 4 callsites** | `updateTagCount(...)` → `weblogTagRepository.updateTagCount(...)` (3 loops in `saveWeblogEntry()`) |
| **Updated 2 callsites** | `removeWeblogEntryTag(tag)` → `weblogTagRepository.removeWeblogEntryTag(tag)` (in `saveWeblogEntry()` and `removeWeblogEntry()`) |
| **Removed method** | `private void updateTagCount(String, Weblog, int)` — 65 lines |
| **Removed method** | `private void removeWeblogEntryTag(WeblogEntryTag)` — 5 lines |
| **Removed import** | `org.apache.roller.weblogger.pojos.WeblogEntryTagAggregate` (no longer used as type) |

**Structural Impact:** Class reduced from 1297 to 1157 lines (−140 lines). Two private method bodies completely removed and replaced with delegation.

### 5.2 `JPAWebloggerModule.java`

| Change | Detail |
|--------|--------|
| **Added binding** | `binder.bind(WeblogTagRepository.class)` |

**Structural Impact:** Guice now manages `WeblogTagRepository` as a singleton. Since it's a concrete class with `@Inject` constructor, the binding is a self-bind that ensures Guice lifecycle management.

---

## 6. Detailed Change Log

| Original Location | Action | New Location |
|--------------------|--------|-------------|
| `JPAWeblogEntryManagerImpl.updateTagCount()` (lines 1046–1110, 65 lines) | Moved verbatim | `WeblogTagRepository.updateTagCount()` |
| `JPAWeblogEntryManagerImpl.removeWeblogEntryTag()` (lines 509–513, 5 lines) | Moved verbatim | `WeblogTagRepository.removeWeblogEntryTag()` |
| `saveWeblogEntry()` line 206: `updateTagCount(tag.getName(), entry.getWebsite(), 1)` | Delegated | `weblogTagRepository.updateTagCount(tag.getName(), entry.getWebsite(), 1)` |
| `saveWeblogEntry()` line 211: `updateTagCount(tag.getName(), entry.getWebsite(), 1)` | Delegated | `weblogTagRepository.updateTagCount(tag.getName(), entry.getWebsite(), 1)` |
| `saveWeblogEntry()` line 218: `updateTagCount(tag.getName(), entry.getWebsite(), -1)` | Delegated | `weblogTagRepository.updateTagCount(tag.getName(), entry.getWebsite(), -1)` |
| `saveWeblogEntry()` line 224: `removeWeblogEntryTag(tag)` | Delegated | `weblogTagRepository.removeWeblogEntryTag(tag)` |
| `removeWeblogEntry()` line 270: `removeWeblogEntryTag(tag)` | Delegated | `weblogTagRepository.removeWeblogEntryTag(tag)` |

---

## 7. Dependency Injection / Wiring Changes

### Constructor Change

```java
// BEFORE
protected JPAWeblogEntryManagerImpl(Weblogger roller, JPAPersistenceStrategy strategy, CommentManager commentManager)

// AFTER
protected JPAWeblogEntryManagerImpl(Weblogger roller, JPAPersistenceStrategy strategy, CommentManager commentManager, WeblogTagRepository weblogTagRepository)
```

### Guice Module Change (`JPAWebloggerModule.java`)

```java
// ADDED
binder.bind(WeblogTagRepository.class);
```

### Dependency Graph

```
JPAWebloggerModule
├── binds WeblogTagRepository (NEW — concrete class self-bind)
├── binds WeblogEntryManager → JPAWeblogEntryManagerImpl (now receives WeblogTagRepository)
└── binds JPAPersistenceStrategy (existing, injected into WeblogTagRepository)
```

**Dependency chain:** `JPAWeblogEntryManagerImpl` → `WeblogTagRepository` → `JPAPersistenceStrategy`. This is a simple linear chain with no cycles. `WeblogTagRepository` does not depend back on `JPAWeblogEntryManagerImpl` or any other manager.

---

## 8. Metrics Before vs After

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| **LOC** (`JPAWeblogEntryManagerImpl`) | 1297 | 1157 | −140 (−10.8%) |
| **Private methods removed** | 2 (70 lines of logic) | 0 | −2 methods |
| **Import count** | Included `WeblogEntryTagAggregate` | Removed | −1 coupling point |
| **CBO** (estimated) | 30 | ~28 | −2 (removed `WeblogEntryTagAggregate` type coupling) |
| **New class LOC** (`WeblogTagRepository`) | — | 138 | Focused, single-responsibility |
| **Feature Envy instances** | 1 (Designite-flagged) | 0 | −100% |
| **Cognitive Complexity** (in context) | 12 (in bloated class) | 12 (in focused class) | Same logic, better context |

---

## 9. Build and Test Verification

### Build

```
Command: mvn compile -pl app -am
Result:  BUILD SUCCESS (7.1s)
```

No new warnings introduced. All warnings are pre-existing (serialization, deprecation).

### Test Comparison

| Metric | Before Refactoring | After Refactoring |
|--------|-------------------|-------------------|
| Tests run | 158 | 158 |
| Failures | 0 | 0 |
| Errors | 0 | 0 |
| Skipped | 1 | 1 |
| Build result | SUCCESS | SUCCESS |

```
Command: mvn clean test -pl app -am
Result:  BUILD SUCCESS
```

---

## 10. Behaviour Preservation Justification

| Concern | Why It Is Preserved |
|---------|--------------------|
| **Persistence operations** | `WeblogTagRepository` receives the same `JPAPersistenceStrategy` singleton via Guice. Calls to `strategy.getNamedQuery()`, `strategy.store()`, `strategy.getNamedUpdate()`, and `strategy.remove()` are character-for-character identical. The JPA `EntityManager` backing these calls is the same thread-local object. |
| **JPQL queries** | Named queries (`WeblogEntryTagAggregate.getByName&WebsiteOrderByLastUsedDesc`, `WeblogEntryTagAggregate.getByName&WebsiteNullOrderByLastUsedDesc`, `WeblogEntryTagAggregate.removeByTotalLessEqual`) are string constants referencing JPA named queries defined in `WeblogEntryTagAggregate` entity annotations. The query names, parameter bindings, and execution are identical. |
| **Entity lifecycle** | `WeblogEntryTagAggregate` entities are created, updated, and deleted using the same `strategy.store()` and `removeq.executeUpdate()` calls. Object identity, merge semantics, and orphan removal are unchanged. |
| **Transaction scope** | No new transaction demarcation was introduced. `updateTagCount()` still executes within the same transaction as `saveWeblogEntry()` / `removeWeblogEntry()` because all parties share the same `JPAPersistenceStrategy` singleton (single `EntityManager` per request). |
| **Execution ordering** | In `saveWeblogEntry()`: tag aggregate updates happen before `strategy.store(entry)`. In `removeWeblogEntry()`: tag removal happens before `strategy.remove(entry)`. This ordering is preserved exactly. |
| **Exception semantics** | `updateTagCount()` and `removeWeblogEntryTag()` declare `throws WebloggerException`. The calling code does not catch or wrap these — exceptions propagate identically to the calling `saveWeblogEntry()` / `removeWeblogEntry()` methods. |
| **Side effects** | The `removeWeblogEntryTag()` method conditionally calls `updateTagCount()` only if `tag.getWeblogEntry().isPublished()` — this conditional logic is moved verbatim. The `strategy.remove(tag)` call fires at the same point in execution. |
| **Singleton lifecycle** | `WeblogTagRepository` is annotated `@com.google.inject.Singleton` — Guice instantiates it exactly once. The lifecycle mirrors other singleton classes in the application. |

**Empirical proof:** The full test suite (`mvn clean test`) produces identical results — 158 tests run, 0 failures, 0 errors, 1 skipped — both before and after refactoring.

---

## 11. Design Decisions and Constraints

### Why No Interface Was Created

The refactoring plan suggests creating a `WeblogTagRepository` as a concrete class, and we followed this approach because:
- The class has a single consumer (`JPAWeblogEntryManagerImpl`)
- It is an internal implementation detail, not a public API contract
- Adding an interface for a single-consumer internal class would be an instance of Unnecessary Abstraction (Smell #7 in the plan)
- If a future need arises (e.g., a caching decorator or test double), an interface can be introduced at that time

### Why Both Methods Were Extracted Together

`removeWeblogEntryTag()` calls `updateTagCount()` — they have a direct dependency. Extracting only `updateTagCount()` while leaving `removeWeblogEntryTag()` behind would require `removeWeblogEntryTag()` to call `weblogTagRepository.updateTagCount()` while simultaneously calling `this.strategy.remove(tag)`, splitting a cohesive unit of work. Moving both methods together keeps the tag persistence lifecycle in one place.

### What Was Intentionally Not Changed

| Element | Why Untouched |
|---------|---------------|
| `getPopularTags()` | This is a **read-only query** method exposed through the `WeblogEntryManager` interface. It queries `WeblogEntryTagAggregate` but does not mutate it. Moving it would require interface changes — a different smell (Insufficient Modularization, Instance 1.1). |
| `getTags()` | Same as above — read-only, interface-bound. |
| `getTagComboExists()` | Same as above — read-only, interface-bound. |
| Tag iteration loops in `saveWeblogEntry()` | These loops determine *which* tags need aggregate updates based on entry publication state. This is entry-management logic, not persistence logic — it correctly stays in the entry manager. |
| `WeblogEntryManager` interface | No methods were added or removed. The refactored methods were private — the public API is unchanged. |

---

## 12. Architectural Impact

### Before

```
JPAWeblogEntryManagerImpl (1297 LOC)
├── saveWeblogEntry() — calls private updateTagCount() and removeWeblogEntryTag()
├── removeWeblogEntry() — calls private removeWeblogEntryTag()
├── private updateTagCount() — 65 lines of JPAPersistenceStrategy operations
└── private removeWeblogEntryTag() — 5 lines calling updateTagCount() + strategy.remove()
```

Tag aggregate persistence was hidden inside private methods of a class whose responsibility is entry management. The logic could not be tested independently, and it inflated the enclosing class's complexity and coupling metrics.

### After

```
JPAWeblogEntryManagerImpl (1157 LOC)
├── saveWeblogEntry() — delegates to weblogTagRepository.updateTagCount() and .removeWeblogEntryTag()
├── removeWeblogEntry() — delegates to weblogTagRepository.removeWeblogEntryTag()
└── [tag persistence methods removed]

WeblogTagRepository (138 LOC) — NEW
├── updateTagCount(String, Weblog, int) — tag aggregate create/update/delete
└── removeWeblogEntryTag(WeblogEntryTag) — tag removal with aggregate decrement
```

Tag aggregate persistence now lives in a focused class with a single responsibility. Benefits:
- **Feature Envy eliminated**: The method now resides in a class whose purpose is tag aggregate persistence — it no longer "envies" another class's data
- **Independent testability**: `WeblogTagRepository` can be unit-tested with a mocked `JPAPersistenceStrategy`, without instantiating the entire entry management infrastructure
- **Reduced coupling**: `JPAWeblogEntryManagerImpl` no longer imports `WeblogEntryTagAggregate` — one less type dependency
- **Clearer architecture**: Tag aggregate management is now explicitly modeled as a separate concern, visible in the project structure

---

## 13. Future Extensibility Benefits

1. **Tag aggregate caching**: If tag counts become a performance bottleneck, a caching layer can wrap `WeblogTagRepository.updateTagCount()` without modifying `JPAWeblogEntryManagerImpl`
2. **Batch tag operations**: The repository can be extended with batch methods (e.g., `updateTagCounts(Map<String, Integer>)`) to reduce database round-trips during bulk entry saves
3. **Test isolation**: Tests for `saveWeblogEntry()` can mock `WeblogTagRepository` to focus on entry persistence behavior without exercising tag aggregate logic
4. **Foundation for further extraction**: The plan (Instance 1.1) envisions extracting all tag-related concerns from `JPAWeblogEntryManagerImpl`. This repository is the first piece of that decomposition.

---

## 14. Limitations and Tradeoffs

| Limitation | Description | Why Acceptable |
|------------|-------------|----------------|
| **No interface** | `WeblogTagRepository` is a concrete class, not backed by an interface | It has a single consumer and is an internal implementation detail. An interface would be Unnecessary Abstraction at this point. |
| **Read-only tag queries not extracted** | `getPopularTags()`, `getTags()`, `getTagComboExists()` remain in `JPAWeblogEntryManagerImpl` | These methods are bound to the `WeblogEntryManager` interface. Extracting them requires interface decomposition (a separate, larger refactoring). |
| **Visibility change** | `updateTagCount()` and `removeWeblogEntryTag()` changed from `private` to `public` | Necessary for cross-class delegation. The methods are accessed only by `JPAWeblogEntryManagerImpl` — no other class calls them. The visibility increase is an acceptable tradeoff for proper responsibility placement. |
| **Slightly more complex dependency graph** | `JPAWeblogEntryManagerImpl` now has 4 constructor parameters instead of 3 | One additional dependency for proper responsibility separation is a worthwhile tradeoff — the constructor parameter count is still well within acceptable bounds. |
