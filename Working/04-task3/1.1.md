# Refactoring 1.1: Insufficient Modularization — Extract Comment Management

**Project:** Apache Roller Weblogger  
**Target Class:** `JPAWeblogEntryManagerImpl`  
**Date:** February 14, 2026  
**Refactoring Type:** Behaviour-Preserving Structural Extraction  

---

## Problem and Resolution Summary

### The Problem

`JPAWeblogEntryManagerImpl` is the central business-logic class in Apache Roller responsible for managing blog content. Over time, it accumulated four distinct responsibilities — entry CRUD, comment management, category management, and tag/statistical queries — all inside a single 1394-line class with 44 public methods. This is a textbook case of **Insufficient Modularization**: the class does too many unrelated things, making it difficult to understand, test, and safely modify.

The concrete harm this causes is that any developer who needs to change how comments work (for example, adding a spam filter or moderation queue) must open and edit the same class that also handles blog entries, categories, and tag aggregation. A mistake in one area can silently break another. Testing comment logic requires instantiating the entire manager with all its dependencies, even though entry/category/tag concerns are irrelevant to the test. The high WMC (197) means cognitive load for any maintainer is extreme — they must hold four domains in their head simultaneously.

### How We Resolved It

We extracted the **comment management** responsibility into its own dedicated class. Specifically:

1. We created a new `CommentManager` interface that declares the 7 comment-related methods
2. We created `JPACommentManagerImpl` that contains the original comment logic, moved verbatim with zero logic changes
3. We modified the original `JPAWeblogEntryManagerImpl` to delegate all comment calls to the new `CommentManager` instead of handling them directly
4. We wired the new class into the Guice dependency injection module

The original `WeblogEntryManager` interface was **not modified** — all its method signatures remain exactly as before. External callers (15+ production classes, 2+ test classes) continue calling `getWeblogEntryManager().saveComment(...)` and never observe any structural change. The delegation is transparent.

### Why This Particular Approach

We chose **Extract Class + Delegation** over alternatives because:

- **Removing methods from the existing interface** would break every caller in the system — an unacceptable blast radius for a refactoring that should be invisible to consumers
- **Using inheritance** (e.g., a `CommentAwareEntryManager` subclass) would create a fragile hierarchy where comments are modelled as a specialization of entry management, which is semantically wrong — comments are a peer concern, not a subtype
- **Moving methods without creating an interface** would lose the ability to substitute or mock the comment component independently, defeating the testability goal
- **Delegation** is the safest structural pattern here: it introduces zero risk of changing runtime behaviour, keeps the existing API intact, and opens the door for future callers to use `CommentManager` directly when ready

The key insight is that the coupling between entries and comments (specifically, `removeWeblogEntry()` calling `getComments()` to clean up comments before deleting an entry) is a **coordination dependency**, not a reason to colocate the logic. After refactoring, `removeWeblogEntry()` still calls `this.getComments()`, which delegates to `commentManager.getComments()` — same result, cleaner structure.

---

## 1. Smell Description

| Attribute | Detail |
|-----------|--------|
| **Smell Name** | Insufficient Modularization |
| **Location** | `app/src/main/java/org/apache/roller/weblogger/business/jpa/JPAWeblogEntryManagerImpl.java` |
| **Interface** | `WeblogEntryManager` |

### Metric Evidence

| Metric | Value | Threshold/Concern |
|--------|-------|--------------------|
| WMC (Weighted Method Complexity) | 197 | Extremely high for a single class |
| LOC | 1394 | Bloated class body |
| Public Methods | 44 | Bloated interface |
| CBO (Coupling Between Objects) | 30 | High coupling to external types |

**Tool Cross-Verification:**
- **Designite Java** — flagged as Insufficient Modularization ("bloated interface, 44 public methods")
- **PMD** — TooManyMethods, CyclomaticComplexity on `getWeblogEntries()` (CC=16)
- **SonarQube** — Cognitive Complexity violations on `updateTagCount()` (CC=12), `saveWeblogEntry()` (CC=15)
- **CK Metrics** — WMC=197, CBO=30, publicMethodsQty=44

### Responsibilities Mixed in This Class

1. **WeblogEntry CRUD** — `saveWeblogEntry()`, `removeWeblogEntry()`, `getWeblogEntry()`, `getWeblogEntryByAnchor()`, `getWeblogEntriesPinnedToMain()`
2. **Comment Management** — `saveComment()`, `removeComment()`, `getComment()`, `getComments()`, `removeMatchingComments()`, `getCommentCount()`
3. **Category Management** — `saveWeblogCategory()`, `removeWeblogCategory()`, `getWeblogCategory()`, `getWeblogCategories()`, `getWeblogCategoryByName()`
4. **Tag & Statistical Queries** — `getPopularTags()`, `getTags()`, `getTagComboExists()`, `getMostCommentedWeblogEntries()`, hit count operations

### Why This Is a Design Problem

The class violates the **Single Responsibility Principle** — a change to comment handling (e.g., adding moderation logic) forces editing the same class that manages entries, categories, tags, and hit counts. This creates concrete engineering problems:

- **Maintenance risk**: Modifying comment query logic (e.g., the JPQL in `getComments()`) requires working inside a 1394-line file that also contains entry persistence, category tree management, and tag aggregation. A developer could inadvertently affect entry-saving logic while fixing a comment bug, because all these concerns share the same class scope and private utilities.
- **Testing difficulty**: To unit-test `saveComment()`, you must construct a `JPAWeblogEntryManagerImpl` with all its dependencies (`Weblogger`, `JPAPersistenceStrategy`), even though entry/category/tag methods are irrelevant. There is no way to test comment logic in isolation.
- **Cognitive overload**: A developer reading this class to understand comment behaviour must wade through 37 unrelated methods to find the 7 relevant ones. The WMC of 197 means the class has more decision points than most developers can hold in working memory.
- **Coupling explosion**: The class imports 30 external types — many only needed by one responsibility. For example, `WeblogEntryTagAggregate` is only relevant to tag operations but contributes to the coupling score of the entire class.
- **Change amplification**: Adding a new comment feature (e.g., threaded replies) would increase the already-bloated method count and complexity of a class that has nothing to do with that feature domain.

---

## 2. Root Cause Analysis

### Architectural Cause

The `WeblogEntryManager` interface was designed as a coarse-grained "manager" covering all content-related operations. The JPA implementation followed this monolithic interface, accumulating every content concern into a single class. As features grew (comments, tags, hit counts), the class absorbed them without structural decomposition.

### Structural Causes

- **Interface-driven coupling**: `WeblogEntryManager` declares all 44 methods, forcing a single implementation class
- **Shared persistence strategy**: All methods use the same `JPAPersistenceStrategy`, which made it convenient to colocate them
- **Incremental feature growth**: Comment management was added alongside entries because comments are domain-adjacent to entries

### Why Responsibilities Became Coupled

`removeWeblogEntry()` internally calls `getComments()` to clean up associated comments before deleting an entry. This runtime dependency created the perception that comment methods *belong* in the same class. However, this is a **coordination dependency**, not a **cohesion indicator**. The entry deletion method needs to *use* comment services, but that does not mean the comment implementation must live in the same class. By analogy, a `UserService` might call `EmailService.sendWelcomeEmail()` during registration — that doesn't mean email-sending logic belongs inside the user service class. The solution is to depend on an abstraction (interface) rather than colocate the implementation.

---

## 3. Refactoring Strategy

### Techniques Applied

1. **Extract Interface** — Created `CommentManager` defining the 7 comment-related method contracts
2. **Extract Class** — Created `JPACommentManagerImpl` implementing the new interface with the original logic moved verbatim
3. **Replace Implementation with Delegation** — Original class delegates all 7 comment methods to the injected `CommentManager`

### Architectural Goal

Separate comment management into an independently testable, single-responsibility component while preserving the existing `WeblogEntryManager` public API as a facade.

### Why This Approach Preserves Behaviour

The critical safety guarantee of this refactoring is that **no logic was rewritten**. Every line of comment-handling code was relocated character-for-character into the new class. The original class now contains thin delegation methods (one-liners that forward the call). This means:

- The same JPQL queries are constructed with the same parameters in the same order
- The same `strategy.store()` / `strategy.remove()` / `strategy.load()` calls execute against the same persistence context
- The same side effect — updating weblog last-modified date via `roller.getWeblogManager().saveWeblog()` — fires on every `saveComment()` and `removeComment()` call
- The same `JPAPersistenceStrategy` singleton is injected into the new class by Guice, so the JPA EntityManager and transaction context are shared across the entire request lifecycle, exactly as before
- Internal callers like `removeWeblogEntry()` call `this.getComments()` which delegates to `commentManager.getComments()` — the call chain adds one hop but produces the identical result

### Why Alternative Approaches Were Rejected

| Alternative | Why Rejected |
|-------------|-------------|
| **Remove comment methods from `WeblogEntryManager` interface** | Would require modifying 15+ production caller classes (`GlobalCommentManagement`, `Comments`, `CommentDataServlet`, `CommentServlet`, `TrackbackServlet`, `CommentsPager`, `SiteModel`, `Weblog`, `WeblogEntry`, wrapper classes) and 2+ test classes. That is not a behaviour-preserving refactoring — it is an API redesign with a massive blast radius. |
| **Use inheritance** (e.g., `CommentAwareEntryManager extends JPAWeblogEntryManagerImpl`) | Semantically incorrect — comment management is not a specialization of entry management, it is a separate concern. Inheritance would create a fragile base class problem where changes to the parent unexpectedly affect the child, and would not actually reduce the responsibility count of the parent. |
| **Move methods without creating a `CommentManager` interface** | Moving concrete methods to a helper class without an interface eliminates the primary benefit: the ability to substitute, decorate, or mock the comment component. Without the interface, callers would be coupled to the concrete implementation, reducing testability and blocking future extension patterns like caching decorators. |
| **Inline delegation (private helper class)** | A private inner class would reduce LOC in the main class but would not enable independent DI wiring, independent testing, or interface-based substitution. The comment logic would remain structurally trapped inside the original class's compilation unit. |

---

## 4. Files Created

### 4.1 `CommentManager.java`

| Attribute | Detail |
|-----------|--------|
| **Path** | `app/src/main/java/org/apache/roller/weblogger/business/CommentManager.java` |
| **Purpose** | Interface defining the comment management contract |
| **Package** | `org.apache.roller.weblogger.business` (same level as `WeblogEntryManager`) |

**Methods Declared:**

| Method | Return Type | Description |
|--------|-------------|-------------|
| `saveComment(WeblogEntryComment)` | `void` | Persist a comment and update weblog last-modified |
| `removeComment(WeblogEntryComment)` | `void` | Delete a comment and update weblog last-modified |
| `getComment(String id)` | `WeblogEntryComment` | Load comment by primary key |
| `getComments(CommentSearchCriteria)` | `List<WeblogEntryComment>` | Dynamic query with filtering, ordering, pagination |
| `removeMatchingComments(...)` | `int` | Bulk delete comments matching criteria |
| `getCommentCount()` | `long` | Site-wide approved comment count |
| `getCommentCount(Weblog)` | `long` | Per-weblog approved comment count |

**Dependencies:** `WebloggerException`, `CommentSearchCriteria`, `Weblog`, `WeblogEntry`, `WeblogEntryComment`, `ApprovalStatus`

---

### 4.2 `JPACommentManagerImpl.java`

| Attribute | Detail |
|-----------|--------|
| **Path** | `app/src/main/java/org/apache/roller/weblogger/business/jpa/JPACommentManagerImpl.java` |
| **Purpose** | JPA implementation of `CommentManager` |
| **Annotation** | `@com.google.inject.Singleton` |

**Constructor Dependencies (Guice-injected):**

| Dependency | Type | Purpose |
|------------|------|---------|
| `roller` | `Weblogger` | Access `WeblogManager` to update weblog last-modified dates on comment save/remove |
| `strategy` | `JPAPersistenceStrategy` | JPA persistence operations (`store`, `remove`, `load`, `getDynamicQuery`, `getNamedQuery`) |

**Key Implementation Details:**
- `getComments()` constructs a dynamic JPQL query with conditional WHERE clauses — logic moved verbatim from original
- `removeMatchingComments()` iterates over `getComments()` results and calls `removeComment()` individually (MySQL limitation prevents bulk DELETE with subquery)
- Includes private `appendConjuctionToWhereclause()` utility (moved from original, no longer needed there)

---

## 5. Files Modified

### 5.1 `JPAWeblogEntryManagerImpl.java`

| Change | Detail |
|--------|--------|
| **Added import** | `org.apache.roller.weblogger.business.CommentManager` |
| **Added field** | `private final CommentManager commentManager` |
| **Modified constructor** | Added `CommentManager commentManager` parameter (Guice-injected) |
| **Replaced 7 method bodies** | Comment methods now delegate to `this.commentManager.*()` |
| **Removed utility method** | `appendConjuctionToWhereclause()` — no longer used after delegation |

**Structural Impact:** Class reduced from 1394 to 1297 lines (−97 lines). Seven method bodies reduced to single-line delegations.

### 5.2 `JPAWebloggerModule.java`

| Change | Detail |
|--------|--------|
| **Added import** | `org.apache.roller.weblogger.business.CommentManager` |
| **Added binding** | `binder.bind(CommentManager.class).to(JPACommentManagerImpl.class)` |

**Structural Impact:** Guice now constructs and injects `JPACommentManagerImpl` as a singleton, wired into `JPAWeblogEntryManagerImpl` via constructor injection.

---

## 6. Detailed Change Log

| Original Location | Action | New Location |
|--------------------|--------|-------------|
| `JPAWeblogEntryManagerImpl.saveComment()` body (lines 161–166) | Moved verbatim | `JPACommentManagerImpl.saveComment()` |
| `JPAWeblogEntryManagerImpl.removeComment()` body (lines 171–176) | Moved verbatim | `JPACommentManagerImpl.removeComment()` |
| `JPAWeblogEntryManagerImpl.getComment()` body (line 751–753) | Moved verbatim | `JPACommentManagerImpl.getComment()` |
| `JPAWeblogEntryManagerImpl.getComments()` body (lines 630–699) | Moved verbatim | `JPACommentManagerImpl.getComments()` |
| `JPAWeblogEntryManagerImpl.removeMatchingComments()` body (lines 703–718) | Moved verbatim | `JPACommentManagerImpl.removeMatchingComments()` |
| `JPAWeblogEntryManagerImpl.getCommentCount()` body (lines 1356–1361) | Moved verbatim | `JPACommentManagerImpl.getCommentCount()` |
| `JPAWeblogEntryManagerImpl.getCommentCount(Weblog)` body (lines 1367–1373) | Moved verbatim | `JPACommentManagerImpl.getCommentCount(Weblog)` |
| `JPAWeblogEntryManagerImpl.appendConjuctionToWhereclause()` (lines 1385–1393) | Moved verbatim | `JPACommentManagerImpl.appendConjuctionToWhereclause()` (private) |

---

## 7. Method Delegation Map

All 7 methods in `JPAWeblogEntryManagerImpl` now delegate to `this.commentManager`:

| Facade Method | Delegates To |
|---------------|-------------|
| `saveComment(comment)` | `commentManager.saveComment(comment)` |
| `removeComment(comment)` | `commentManager.removeComment(comment)` |
| `getComment(id)` | `commentManager.getComment(id)` |
| `getComments(csc)` | `commentManager.getComments(csc)` |
| `removeMatchingComments(...)` | `commentManager.removeMatchingComments(...)` |
| `getCommentCount()` | `commentManager.getCommentCount()` |
| `getCommentCount(website)` | `commentManager.getCommentCount(website)` |

**Internal caller preserved:** `removeWeblogEntry()` calls `getComments()` which routes through the delegation — behaviour unchanged.

---

## 8. Dependency Injection / Wiring Changes

### Constructor Change

```java
// BEFORE
protected JPAWeblogEntryManagerImpl(Weblogger roller, JPAPersistenceStrategy strategy)

// AFTER
protected JPAWeblogEntryManagerImpl(Weblogger roller, JPAPersistenceStrategy strategy, CommentManager commentManager)
```

### Guice Module Change (`JPAWebloggerModule.java`)

```java
// ADDED
binder.bind(CommentManager.class).to(JPACommentManagerImpl.class);
```

### Dependency Graph

```
JPAWebloggerModule
├── binds CommentManager → JPACommentManagerImpl (NEW)
├── binds WeblogEntryManager → JPAWeblogEntryManagerImpl (existing, now receives CommentManager)
└── binds Weblogger → JPAWebloggerImpl (existing, unchanged)
```

**Circular dependency note:** `JPACommentManagerImpl` → `Weblogger` → `JPAWebloggerImpl` → `WeblogEntryManager` → `JPAWeblogEntryManagerImpl` → `CommentManager`. This mirrors the pre-existing circular pattern across all JPA managers. Guice resolves it via singleton proxy injection. Tests confirm no runtime issues.

---

## 9. Metrics Before vs After

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| **LOC** (`JPAWeblogEntryManagerImpl`) | 1394 | 1297 | −97 (−7%) |
| **WMC** (estimated) | 197 | ~165 | −32 (~−16%) |
| **Public methods with logic** | 44 | 37 | −7 (delegations don't contribute complexity) |
| **Responsibilities** | 4 (entry, comment, category, stats) | 3 (entry, category, stats) | −1 |
| **New class LOC** (`JPACommentManagerImpl`) | — | ~210 | Focused, single-responsibility |
| **CBO** (estimated) | 30 | ~27 | −3 (comment-specific types isolated) |

---

## 10. Build and Test Verification

### Build

```
Command: mvn compile -pl app -am
Result:  BUILD SUCCESS (6.9s)
```

No new warnings introduced. All warnings in output are pre-existing (serialization, deprecation).

### Test Comparison

| Metric | Before Refactoring | After Refactoring |
|--------|-------------------|-------------------|
| Tests run | 158 | 158 |
| Failures | 0 | 0 |
| Errors | 0 | 0 |
| Skipped | 1 | 1 |
| Build result | SUCCESS | SUCCESS |

```
Command: mvn clean test
Result:  BUILD SUCCESS
```

---

## 11. Design Decisions and Constraints

### Why `WeblogEntryManager` Interface Was Preserved

The `WeblogEntryManager` interface is the established contract through which the entire application accesses content management operations. It is referenced by **15+ production classes** and **2+ test classes** via `WebloggerFactory.getWeblogger().getWeblogEntryManager()`. Every Struts action, every servlet, every rendering model, and every test class in the comment domain calls comment methods through this interface.

Removing comment methods from this interface would be a **breaking API change**, not a refactoring. Every caller would need to be updated to obtain a `CommentManager` instead — a change that touches the UI layer, the rendering layer, the POJO layer, and the test layer simultaneously. That level of cross-cutting modification belongs in a separate, carefully planned phase, not bundled with an internal structural improvement.

By preserving the interface, we guarantee that **this refactoring is invisible to every consumer**.

### Why Delegation Was Used Instead of Direct Removal

Delegation is the standard technique for decomposing a class without changing its external contract. The original `JPAWeblogEntryManagerImpl` becomes a **facade**: it still satisfies the `WeblogEntryManager` interface, but internally it forwards comment operations to the dedicated `CommentManager` implementation. This pattern:

- Preserves binary compatibility — no recompilation of callers needed
- Enables **incremental migration** — callers can be updated one-by-one in a future phase to use `CommentManager` directly
- Keeps the refactoring **purely structural** — the runtime call graph changes by one additional method call, but the business logic is identical

### What Was Intentionally Not Changed

| Element | Why Untouched |
|---------|---------------|
| `WeblogEntryManager` interface | Facade preservation rule — no external API change |
| `Weblogger` interface / `WebloggerImpl` | No `getCommentManager()` accessor added — minimise blast radius |
| `removeWeblogEntry()` logic | Only its internal route to `getComments()` changed (via delegation, not logic) |
| `getMostCommentedWeblogEntries()` | This is a statistical/entry query, not a comment management operation |
| `applyCommentDefaultsToEntries()` | Operates on `WeblogEntry` entities, not on comments directly |

---

## 12. Behaviour Preservation Justification

The core question for any structural refactoring is: **does the system behave identically before and after?** Here is the analysis for each dimension of behaviour:

| Concern | Why It Is Preserved |
|---------|--------------------|
| **Persistence operations** | The new `JPACommentManagerImpl` receives the same `JPAPersistenceStrategy` singleton via Guice. Calls to `strategy.store()`, `remove()`, `load()`, `getDynamicQuery()`, and `getNamedQuery()` are character-for-character identical to the original code. The JPA EntityManager backing these calls is the same object. |
| **Side effects** | Both `saveComment()` and `removeComment()` include a side effect: `roller.getWeblogManager().saveWeblog(comment.getWeblogEntry().getWebsite())` to update the weblog's last-modified timestamp. This line was moved verbatim — the side effect fires at exactly the same point in execution. |
| **JPQL queries** | `getComments()` builds a dynamic JPQL query string with conditional WHERE clauses based on `CommentSearchCriteria`. Every conditional branch, every parameter binding, every ORDER BY clause is identical. The generated SQL hitting the database is the same. |
| **Exception semantics** | All 7 methods declare `throws WebloggerException`. The delegation methods in the facade do not catch or wrap exceptions — they propagate directly from the implementation, preserving the original exception type and message. |
| **Transaction scope** | Apache Roller uses a single `JPAPersistenceStrategy` per request (Guice singleton scope). Both the original class and the new class share this singleton, so they participate in the same JPA persistence context and the same transaction boundaries. No additional transaction demarcation was introduced. |
| **Singleton lifecycle** | Both classes are annotated `@com.google.inject.Singleton`. Guice instantiates each exactly once. The lifecycle (construction, use, release) is identical to the pre-refactoring state. |
| **Internal cross-calls** | `removeWeblogEntry()` calls `this.getComments(csc)` to find comments to delete before removing an entry. After refactoring, `this.getComments(csc)` delegates to `commentManager.getComments(csc)`. The result is an identical `List<WeblogEntryComment>` — the deletion loop proceeds unchanged. |

**Empirical proof:** The full test suite (`mvn clean test`) produces identical results — 158 tests run, 0 failures, 0 errors, 1 skipped — both before and after refactoring.

---

## 13. Architectural Impact

### Before
```
WeblogEntryManager (interface: 44 methods)
└── JPAWeblogEntryManagerImpl (1394 LOC, 4 mixed responsibilities)
```

Every caller — whether it needed to save a comment, fetch a category, or query tag statistics — went through the same monolithic class. There was no structural boundary between these concerns. A change to comment query logic and a change to tag aggregation logic would appear as modifications to the same file in version control, making code review harder and merge conflicts more likely.

### After
```
WeblogEntryManager (interface: 44 methods, unchanged facade)
└── JPAWeblogEntryManagerImpl (1297 LOC, 3 responsibilities + delegation)
    └── delegates comment ops to:
        CommentManager (interface: 7 methods)
        └── JPACommentManagerImpl (210 LOC, 1 responsibility)
```

Comment management now lives behind a clean interface boundary. This means:

- **Isolation of change**: Modifying comment handling (e.g., adding approval workflows, spam detection, notification triggers) only touches `JPACommentManagerImpl`. The entry, category, and tag code paths are structurally separate and cannot be accidentally affected.
- **Focused code review**: Changes to comment logic appear as modifications to a 210-line file with a single responsibility, not buried inside a 1394-line file with four responsibilities.
- **Independent testability**: `JPACommentManagerImpl` can be unit-tested with a mocked `JPAPersistenceStrategy` and `Weblogger`, without instantiating any entry/category/tag infrastructure.
- **Substitutability**: The `CommentManager` interface allows the implementation to be swapped via Guice rebinding — for example, replacing it with a caching decorator during performance optimisation, or with a test double during integration testing.

---

## 14. Future Extensibility Benefits

This refactoring is the first step in a larger decomposition of `JPAWeblogEntryManagerImpl`. The same Extract Class + Delegation pattern can be applied next to category management and tag/statistics management. Each extraction further reduces the original class's complexity and responsibility count.

Specific extensibility benefits from this step:

1. **Independent comment features**: Adding comment moderation, spam filtering, threaded replies, or approval workflows only requires modifying `JPACommentManagerImpl`. There is zero risk of accidentally breaking entry persistence, category management, or tag aggregation, because those code paths live in a different class.

2. **Decorator pattern**: Because `CommentManager` is an interface, a `CachingCommentManager` or `AuditingCommentManager` can wrap the JPA implementation transparently. For example, caching `getCommentCount()` results would be a new class implementing `CommentManager` that delegates to `JPACommentManagerImpl` — no modification of any existing class.

3. **Direct access path**: In a future phase, a `Weblogger.getCommentManager()` accessor can be added to the facade. Callers would then access `getCommentManager().saveComment(...)` directly, bypassing the `WeblogEntryManager` delegation. The facade methods in `JPAWeblogEntryManagerImpl` could then be deprecated and eventually removed.

4. **Testability**: Tests that exercise entry logic (e.g., `saveWeblogEntry()`, `removeWeblogEntry()`) can now mock `CommentManager` to isolate entry behaviour from comment behaviour. This was impossible before because both concerns were private implementation details of the same class.

5. **Parallel development**: Two developers can now work on comment features and entry features simultaneously without file-level merge conflicts, because the logic lives in separate files.

---

## 15. Limitations and Tradeoffs

Every refactoring involves tradeoffs. Here are the conscious limitations of this approach:

| Limitation | Description | Why Acceptable |
|------------|-------------|----------------|
| **Indirect access** | Callers still access comment operations through `WeblogEntryManager` → delegation adds one method call of indirection | The indirection cost is a single method dispatch — negligible in a web application where each request involves hundreds of method calls and at least one database roundtrip |
| **Interface duplication** | Comment method signatures exist in both `WeblogEntryManager` and `CommentManager` | Necessary for facade preservation; the duplication is in signatures only (7 one-line delegations), not in logic |
| **No direct accessor** | `Weblogger` interface does not yet expose `getCommentManager()` | Intentional scope limitation — adding a facade accessor touches `Weblogger`, `WebloggerImpl`, and `JPAWebloggerImpl`, which is a separate concern best handled in a follow-up refactoring |
| **Circular DI** | `JPACommentManagerImpl` → `Weblogger` → `JPAWebloggerImpl` → `WeblogEntryManager` → `JPAWeblogEntryManagerImpl` → `CommentManager` | This mirrors the pre-existing circular pattern across all JPA managers in the codebase. Guice resolves it via singleton proxy injection. Tests confirm no runtime issues. |
| **Partial decomposition** | Only 1 of 4 responsibilities extracted — `JPAWeblogEntryManagerImpl` still has 37 methods with logic | This is an incremental refactoring by design. Extracting all four responsibilities simultaneously would be a high-risk "big bang" change. The comment extraction establishes the pattern; category and tag extractions can follow the same template with lower risk. |
