# Refactoring 4.1: Cyclically-Dependent Modularization — Break EntryCollection ↔ RollerAtomHandler Cycle

**Project:** Apache Roller Weblogger  
**Target Classes:** `EntryCollection`, `RollerAtomHandler` (cycle participants); `MediaCollection` (propagated change)  
**Date:** February 14, 2026  
**Refactoring Type:** Behaviour-Preserving Dependency Inversion  

---

## Problem and Resolution Summary

### The Problem

`EntryCollection` and `RollerAtomHandler` are cyclically dependent on each other, creating a compile-time dependency loop that prevents either class from being understood, tested, or modified in isolation.

The cycle manifests as follows:
- **`RollerAtomHandler` → `EntryCollection`**: The handler creates `new EntryCollection(user, atomURL)` in five methods (`postEntry`, `getEntry`, `getCollection`, `putEntry`, `deleteEntry`) to delegate Atom protocol operations for blog entries.
- **`EntryCollection` → `RollerAtomHandler`**: The collection calls back into `RollerAtomHandler` for authorization (`canEdit`, `canView`) and rate-limiting (`oneSecondThrottle`) via 7 static method invocations.

The concrete harm is:
- **Test impossibility**: You cannot write a unit test for `EntryCollection` without loading `RollerAtomHandler` and all its authentication dependencies (WSSE, OAuth, BASIC auth). Conversely, testing `RollerAtomHandler` loads `EntryCollection`, which calls back into the handler's static methods.
- **Build fragility**: Any change to either class's public API risks breaking the other, because they are structurally intertwined.
- **Cognitive coupling**: Understanding `EntryCollection`'s behavior requires understanding `RollerAtomHandler`'s authorization model, and vice versa — a developer cannot reason about one without the other.
- **Parallel `MediaCollection` cycle**: `MediaCollection` exhibits the identical cyclic pattern (5 static calls to `RollerAtomHandler`), compounding the problem.

### How We Resolved It

We applied the **Dependency Inversion Principle** by introducing an `AtomRequestContext` interface that abstracts the capabilities `EntryCollection` (and `MediaCollection`) need from the handler:

1. Created `AtomRequestContext` interface declaring 7 methods: `getAuthenticatedUser()`, `getAtomURL()`, `canEdit(User, Weblog)`, `canEdit(User, WeblogEntry)`, `canView(User, Weblog)`, `canView(User, WeblogEntry)`, `oneSecondThrottle()`
2. Made `RollerAtomHandler` implement `AtomRequestContext` — converting the 5 static utility methods (`canEdit`, `canView`, `oneSecondThrottle`) to instance methods
3. Changed `EntryCollection` constructor from `(User user, String atomURL)` to `(AtomRequestContext context, Weblogger roller)` — the collection now depends on the abstraction, not the concrete handler
4. Updated `MediaCollection` constructor identically (propagated change to break the parallel cycle)
5. Updated all call sites in `RollerAtomHandler` to pass `this` as the context and `this.roller` as the Weblogger instance

### Why This Particular Approach

We chose **Extract Interface + Dependency Inversion** over alternatives because:

- **Extracting static methods to a utility class** would break the cycle mechanically but would not establish a clean architectural boundary. The authorization concern would live in an orphaned utility with no interface, reducing testability and extensibility.
- **Passing individual authorization callbacks** (e.g., `Function<User, Boolean>`) would add complexity without establishing a named, documentable contract. The interface gives the abstraction a name and a place in the architecture.
- **Making EntryCollection a nested class of RollerAtomHandler** would eliminate the cycle but would increase the handler's already-substantial 533 LOC and merge two distinct responsibilities (HTTP dispatch and blog entry CRUD).
- **Dependency Inversion** is the canonical solution for cyclic dependencies: high-level modules (collections) depend on abstractions (interface), and low-level modules (handler) implement them. This follows SOLID principles and enables substitution for testing.

The key insight is that `EntryCollection` never needs a `RollerAtomHandler` — it needs the *capabilities* that `RollerAtomHandler` provides (authentication context, authorization, throttling). By naming those capabilities in an interface, we decouple the structural dependency while preserving the runtime relationship.

---

## 1. Smell Description

| Attribute | Detail |
|-----------|--------|
| **Smell Name** | Cyclically-Dependent Modularization |
| **Location** | `app/src/main/java/org/apache/roller/weblogger/webservices/atomprotocol/EntryCollection.java` ↔ `RollerAtomHandler.java` |
| **Cycle Type** | Compile-time bidirectional dependency |

### Metric Evidence

| Class | Metric | Value |
|-------|--------|-------|
| `EntryCollection` | WMC | 60 |
| `EntryCollection` | CBO | 29 |
| `EntryCollection` | LOC | 474 |
| `RollerAtomHandler` | WMC | 67 |
| `RollerAtomHandler` | CBO | 22 |
| `RollerAtomHandler` | LOC | 533 |

**Tool Cross-Verification:**
- **Designite Java** — flagged `EntryCollection` with Cyclically-dependent Modularization ("Participating classes: RollerAtomHandler; EntryCollection")
- **CK Metrics** — CBO of 29 for `EntryCollection` (high coupling)

### Dependency Cycle Detail

```
RollerAtomHandler
├─ Creates: new EntryCollection(user, atomURL) — 5 call sites
├─ Creates: new MediaCollection(user, atomURL) — 5 call sites
└─ Provides: user, atomURL, roller (from WebloggerFactory singleton)

EntryCollection
├─ Calls: RollerAtomHandler.canEdit(user, website)     — 2 times
├─ Calls: RollerAtomHandler.canEdit(user, entry)       — 1 time
├─ Calls: RollerAtomHandler.canView(user, entry)       — 1 time
├─ Calls: RollerAtomHandler.canView(user, website)     — 1 time
├─ Calls: RollerAtomHandler.oneSecondThrottle()        — 2 times
└─ Total: 7 static back-references to RollerAtomHandler → CYCLE
```

### Why This Is a Design Problem

The cyclic dependency creates a **structurally inseparable pair**. This causes:

- **Test isolation failure**: A unit test for `EntryCollection.postEntry()` must load `RollerAtomHandler.class` because `EntryCollection` calls `RollerAtomHandler.canEdit()`. But loading `RollerAtomHandler` triggers its static initializer (reading `WebloggerConfig` for the `THROTTLE` flag), requiring the full Roller configuration system. You cannot test entry posting without bootstrapping the entire web application context.
- **Compilation coupling**: Modifying `RollerAtomHandler`'s method signatures (e.g., renaming `canEdit` to `isAuthorizedToEdit`) would break `EntryCollection`, and vice versa.
- **Module boundary violation**: The `atomprotocol` package should contain distinct components (handler, entry collection, media collection) that can evolve independently. The cycle makes the package a monolith in practice.

---

## 2. Root Cause Analysis

### Architectural Cause

The original design placed authorization logic (permission checks) and throttling logic (rate limiting) inside `RollerAtomHandler` as static utility methods. When `EntryCollection` was extracted from the handler to reduce its size, the new class inherited a dependency on the handler's static methods. Since the handler already depended on `EntryCollection` (it creates instances), a cycle was born.

### Structural Causes

- **Static method coupling**: `RollerAtomHandler.canEdit()`, `canView()`, and `oneSecondThrottle()` are `public static` methods. Static methods cannot be overridden, mocked, or injected — they create hard compile-time dependencies from any caller.
- **Missing abstraction**: There was no interface representing "the capabilities a collection needs from its context." The collection was directly coupled to the concrete handler.
- **Singleton lookup**: `EntryCollection` obtained its `Weblogger` reference via `WebloggerFactory.getWeblogger()` — a static singleton call that further hardwired it into the global dependency graph.

### Why the Cycle Is Not Just Cosmetic

Some cyclic dependencies are benign (e.g., JPA bidirectional entity relationships managed by an ORM). This cycle is **structural and harmful** because:
- The classes are separate compilation units with different responsibilities (HTTP dispatch vs. entry CRUD)
- The back-references are to authorization logic, not to data relationships
- The static method calls prevent any form of substitution or mocking

---

## 3. Refactoring Strategy

### Technique Applied

**Extract Interface + Dependency Inversion Principle (DIP)**

The standard GoF solution for breaking cyclic dependencies: introduce an abstraction (interface) that both sides can depend on without depending on each other.

### Architectural Goal

```
BEFORE (cycle):
    RollerAtomHandler ──→ EntryCollection ──→ RollerAtomHandler

AFTER (acyclic via DIP):
    AtomRequestContext (interface)
           ↑ implements              ↑ depends on
    RollerAtomHandler ──creates──→ EntryCollection
```

Both `RollerAtomHandler` and `EntryCollection` depend on `AtomRequestContext`, but neither depends on the other. The cycle is broken.

### Why This Approach Preserves Behaviour

The safety guarantee rests on three facts:

1. **Same authorization logic**: The `canEdit()` and `canView()` methods contain the same code — the only change is from `static` to instance dispatch. The authorization checks (`entry.hasWritePermissions(u)`, `website.hasUserPermission(u, WeblogPermission.POST)`) are executed identically.

2. **Same throttle semantics**: `oneSecondThrottle()` retains `synchronized(RollerAtomHandler.class)` — synchronizing on the class object, not the instance. This preserves the original cross-request throtteling behavior where all concurrent handlers share a single lock.

3. **Same object identity**: In `RollerAtomHandler`, collections are created with `new EntryCollection(this, this.roller)`. The `this` reference provides the same `user` and `atomURL` that were previously passed individually. `this.roller` is the same `WebloggerFactory.getWeblogger()` singleton that `EntryCollection` previously obtained independently in its constructor.

### Why Alternative Approaches Were Rejected

| Alternative | Why Rejected |
|-------------|-------------|
| **Extract static methods to a utility class** | Would break the cycle mechanically but would leave authorization as disconnected static utilities without a contract. No interface means no substitutability, no mockability, and no named abstraction for the "context a collection needs." |
| **Move authorization into EntryCollection** | Would duplicate the authorization logic (MediaCollection also needs it) and would mix two responsibilities (entry CRUD + permission checking) inside the collection class, worsening its cohesion. |
| **Make EntryCollection a nested class of RollerAtomHandler** | Would merge the classes back together, increasing RollerAtomHandler from 533 to ~1,000 LOC and defeating the purpose of the original extraction. |
| **Use method references / callbacks** | Would avoid the cycle but at the cost of readability. Passing `Function<User, Boolean>` callbacks to a constructor is less clear than implementing a named interface with documented methods. |

---

## 4. Files Created

### 4.1 `AtomRequestContext.java`

| Attribute | Detail |
|-----------|--------|
| **Path** | `app/src/main/java/org/apache/roller/weblogger/webservices/atomprotocol/AtomRequestContext.java` |
| **Purpose** | Interface abstracting authentication context, authorization, and throttling |
| **Package** | `org.apache.roller.weblogger.webservices.atomprotocol` |

**Methods Declared:**

| Method | Return Type | Description |
|--------|-------------|-------------|
| `getAuthenticatedUser()` | `User` | Return the authenticated user for this request |
| `getAtomURL()` | `String` | Return the base Atom protocol URL |
| `canEdit(User, Weblog)` | `boolean` | Check if user can create/edit entries and uploads in a weblog |
| `canEdit(User, WeblogEntry)` | `boolean` | Check if user can edit a specific entry |
| `canView(User, Weblog)` | `boolean` | Check if user can view a weblog |
| `canView(User, WeblogEntry)` | `boolean` | Check if user can view a specific entry |
| `oneSecondThrottle()` | `void` | Apply rate-limiting pause if configured |

**Dependencies:** `User`, `Weblog`, `WeblogEntry` (all POJOs — no service-layer or infrastructure dependencies)

---

## 5. Files Modified

### 5.1 `RollerAtomHandler.java`

| Change | Detail |
|--------|--------|
| **Added interface** | `implements AtomRequestContext` added to class declaration |
| **Added methods** | `getAuthenticatedUser()`, `getAtomURL()` — new `@Override` methods exposing existing fields |
| **Converted static → instance** | `canEdit(User, WeblogEntry)`, `canEdit(User, Weblog)`, `canView(User, WeblogEntry)`, `canView(User, Weblog)`, `oneSecondThrottle()` — removed `static` keyword, added `@Override` |
| **Updated constructor calls** | 5× `new EntryCollection(user, atomURL)` → `new EntryCollection(this, this.roller)` |
| **Updated constructor calls** | 5× `new MediaCollection(user, atomURL)` → `new MediaCollection(this, this.roller)` |

**Structural Impact:** Class slightly modified but same LOC. No methods added or removed beyond the two trivial accessors. The authorization and throttle logic is identical — only the dispatch mechanism changed (static → instance).

**Synchronization note:** `oneSecondThrottle()` retains `synchronized(RollerAtomHandler.class)` to preserve the class-level lock semantics. If it used `synchronized(this)`, each handler instance (one per HTTP request) would have its own lock, which would eliminate the cross-request throttling that the original design intended.

### 5.2 `EntryCollection.java`

| Change | Detail |
|--------|--------|
| **Removed import** | `org.apache.roller.weblogger.business.WebloggerFactory` |
| **Added field** | `private final AtomRequestContext context` |
| **Changed constructor** | `(User user, String atomURL)` → `(AtomRequestContext context, Weblogger roller)` |
| **Replaced 7 static calls** | `RollerAtomHandler.canEdit(...)` → `context.canEdit(...)` (3×); `RollerAtomHandler.canView(...)` → `context.canView(...)` (2×); `RollerAtomHandler.oneSecondThrottle()` → `context.oneSecondThrottle()` (2×) |
| **Removed singleton lookup** | `WebloggerFactory.getWeblogger()` in constructor → receives `Weblogger` as parameter |

**Structural Impact:** The class no longer imports `RollerAtomHandler`. The cycle is broken. Constructor signature changed, but the class is only instantiated from `RollerAtomHandler` (5 call sites, all updated).

### 5.3 `MediaCollection.java` (propagated change)

| Change | Detail |
|--------|--------|
| **Added field** | `private final AtomRequestContext context` |
| **Changed constructor** | `(User user, String atomURL)` → `(AtomRequestContext context, Weblogger roller)` |
| **Replaced 5 static calls** | `RollerAtomHandler.canEdit(...)` → `context.canEdit(...)` (4×); `RollerAtomHandler.canView(...)` → `context.canView(...)` (1×) |
| **Removed singleton lookup** | `WebloggerFactory.getWeblogger()` in constructor → receives `Weblogger` as parameter |

**Why propagated:** `MediaCollection` has the identical cyclic dependency pattern. Leaving it unchanged while removing the `static` keyword from `RollerAtomHandler`'s methods would break its compilation. Since `MediaCollection`'s constructor is only called from `RollerAtomHandler` (5 call sites, all updated), the propagation is safe and confined.

---

## 6. Detailed Change Log

| Original Location | Action | New Location |
|--------------------|--------|-------------|
| `RollerAtomHandler.canEdit(User, WeblogEntry)` (static) | Converted to instance method | `RollerAtomHandler.canEdit(User, WeblogEntry)` (instance, `@Override` of `AtomRequestContext`) |
| `RollerAtomHandler.canEdit(User, Weblog)` (static) | Converted to instance method | `RollerAtomHandler.canEdit(User, Weblog)` (instance, `@Override` of `AtomRequestContext`) |
| `RollerAtomHandler.canView(User, WeblogEntry)` (static) | Converted to instance method | `RollerAtomHandler.canView(User, WeblogEntry)` (instance, `@Override` of `AtomRequestContext`) |
| `RollerAtomHandler.canView(User, Weblog)` (static) | Converted to instance method | `RollerAtomHandler.canView(User, Weblog)` (instance, `@Override` of `AtomRequestContext`) |
| `RollerAtomHandler.oneSecondThrottle()` (static) | Converted to instance method | `RollerAtomHandler.oneSecondThrottle()` (instance, `@Override` of `AtomRequestContext`) |
| `EntryCollection` constructor | Changed signature | Takes `(AtomRequestContext, Weblogger)` instead of `(User, String)` |
| `MediaCollection` constructor | Changed signature | Takes `(AtomRequestContext, Weblogger)` instead of `(User, String)` |
| 7 static calls in `EntryCollection` | Replaced with instance calls on `context` | `context.canEdit(...)`, `context.canView(...)`, `context.oneSecondThrottle()` |
| 5 static calls in `MediaCollection` | Replaced with instance calls on `context` | `context.canEdit(...)`, `context.canView(...)` |
| 10 constructor calls in `RollerAtomHandler` | Updated to new signature | `new EntryCollection(this, this.roller)`, `new MediaCollection(this, this.roller)` |

---

## 7. Dependency Graph Before vs After

### Before (Cyclic)

```
RollerAtomHandler ──creates──→ EntryCollection ──static calls──→ RollerAtomHandler  ← CYCLE
                  ──creates──→ MediaCollection ──static calls──→ RollerAtomHandler  ← CYCLE
```

### After (Acyclic via DIP)

```
                    AtomRequestContext (interface)
                     ↑ implements        ↑ depends on
RollerAtomHandler ──creates──→ EntryCollection
                  ──creates──→ MediaCollection ──depends on──→ AtomRequestContext
```

- `EntryCollection` depends only on `AtomRequestContext` (interface) — not on `RollerAtomHandler`
- `MediaCollection` depends only on `AtomRequestContext` (interface) — not on `RollerAtomHandler`
- `RollerAtomHandler` implements `AtomRequestContext` and creates collection instances
- **No cycles exist.** All dependencies flow in one direction through the interface.

---

## 8. Dependency Injection / Wiring Changes

This refactoring does not involve Guice or any DI framework. The wiring is via constructor parameters:

### Constructor Call Changes

```java
// BEFORE (in RollerAtomHandler):
EntryCollection ecol = new EntryCollection(user, atomURL);
MediaCollection mcol = new MediaCollection(user, atomURL);

// AFTER (in RollerAtomHandler):
EntryCollection ecol = new EntryCollection(this, this.roller);
MediaCollection mcol = new MediaCollection(this, this.roller);
```

`this` provides the `AtomRequestContext` interface. `this.roller` provides the `Weblogger` singleton (same object that collections previously obtained from `WebloggerFactory.getWeblogger()`).

---

## 9. Metrics Before vs After

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| **Cyclic dependencies** (EntryCollection ↔ RollerAtomHandler) | 1 cycle | 0 | −100% |
| **Cyclic dependencies** (MediaCollection ↔ RollerAtomHandler) | 1 cycle | 0 | −100% |
| **CBO** (`EntryCollection`) | 29 | ~27 | −2 (removed dep on RollerAtomHandler, added dep on AtomRequestContext) |
| **CBO** (`RollerAtomHandler`) | 22 | 22 | 0 (now implements interface, but already depended on collection classes) |
| **New types** | 0 | 1 (`AtomRequestContext`) | +1 interface |
| **LOC** (`RollerAtomHandler`) | 533 | ~552 | +19 (two trivial accessor methods + `@Override` annotations) |
| **LOC** (`EntryCollection`) | 474 | ~475 | +1 (context field) |
| **LOC** (`MediaCollection`) | 610 | ~611 | +1 (context field) |
| **Static methods** (`RollerAtomHandler`) | 5 | 0 | −5 (converted to instance) |

---

## 10. Build and Test Verification

### Build

```
Command: mvn compile -pl app -am
Result:  BUILD SUCCESS (6.9s)
```

No new warnings introduced. All warnings in output are pre-existing (serialization, deprecation).

### Test Comparison

| Metric | Before Refactoring | After Refactoring |
|--------|-------------------|-------------------|
| Tests run | 158 | 158 |
| Failures | 0 | 0 |
| Errors | 0 | 0 |
| Skipped | 1 | 1 |
| Build result | SUCCESS | SUCCESS |

```
Command: mvn clean test
Result:  BUILD SUCCESS
```

---

## 11. Design Decisions and Constraints

### Why Static Methods Were Converted to Instance Methods

Java does not permit a class to have both a static method and an instance method with the same name and parameter types. Since the `AtomRequestContext` interface declares `canEdit(User, Weblog)` as an instance method, `RollerAtomHandler` cannot simultaneously have `public static boolean canEdit(User u, Weblog website)` and `@Override public boolean canEdit(User u, Weblog website)`. Converting to instance methods is the only option that preserves the method names and parameter signatures.

This conversion is safe because:
- The static methods contain no instance state — they only use their parameters
- The `THROTTLE` static field remains accessible from instance methods (static fields are accessible in instance context)
- The `oneSecondThrottle()` method explicitly synchronizes on `RollerAtomHandler.class` (not `this`), preserving the original class-level locking semantics

### Why MediaCollection Was Also Modified

`MediaCollection` has the same structural pattern as `EntryCollection`: it calls `RollerAtomHandler.canEdit()` and `RollerAtomHandler.canView()` as static methods. When these methods were converted to instance methods (required for the interface implementation), `MediaCollection`'s static calls would no longer compile. Rather than leave a broken class, we applied the same interface-based pattern to `MediaCollection` — this is a **necessary structural propagation**, not a separate refactoring.

Both collection classes:
- Are only instantiated from `RollerAtomHandler` (no other callers)
- Follow the identical pattern (constructor takes `User` + `atomURL`, calls static auth methods)
- Benefit equally from the interface abstraction (both become independently testable)

### What Was Intentionally Not Changed

| Element | Why Untouched |
|---------|---------------|
| `RollerAtomHandlerFactory` | Returns `AtomHandler` interface type — no change needed |
| `RollerAtomService` | Does not reference `RollerAtomHandler`'s static methods — no cycle participation |
| `MediaCollection` internal `WebloggerFactory.getWeblogger()` calls (lines 105, 216) | Pre-existing direct singleton calls in method bodies (not constructor). These are outside the cycle-breaking scope and their modification would be a separate cleanup. |
| `package-info.java` | Documentation-only file — no structural relevance |
| Authentication methods (`authenticateWSSE`, `authenticateBASIC`, `authenticationOAUTH`) | Internal to `RollerAtomHandler`, not part of the cycle |

---

## 12. Behaviour Preservation Justification

| Concern | Why It Is Preserved |
|---------|--------------------|
| **Authorization logic** | `canEdit(User, WeblogEntry)` calls `entry.hasWritePermissions(u)` — identical code, same parameters, same return value. `canEdit(User, Weblog)` calls `website.hasUserPermission(u, WeblogPermission.POST)` — identical. `canView` delegates to `canEdit` — identical. The only change is the dispatch mechanism (static → virtual), which does not affect the logic executed. |
| **Throttle semantics** | `oneSecondThrottle()` retains `synchronized(RollerAtomHandler.class)` — the lock target is the class object, not the instance. This means all concurrent `RollerAtomHandler` instances (one per HTTP request) still share a single lock, throttling at the same rate as before. If we had used `synchronized(this)`, each request would have its own lock, eliminating the cross-request throttle — that would be a behavioral change. By explicitly synchronizing on `.class`, we preserve identical concurrency semantics. |
| **Object identity** | Collections previously received `user` (a `User` object) and `atomURL` (a `String`) — now they receive `this` (whose `getAuthenticatedUser()` returns the same `user` field, and `getAtomURL()` returns the same `atomURL` field) and `this.roller` (the same `WebloggerFactory.getWeblogger()` singleton the collection previously obtained in its constructor). Same objects, same lifecycle. |
| **Exception propagation** | No try-catch blocks were added or modified. `AtomException`, `AtomNotFoundException`, `AtomNotAuthorizedException` propagate identically. |
| **Collection lifecycle** | Each handler method creates a fresh collection instance per call — this pattern is unchanged. `new EntryCollection(this, this.roller)` creates a new object each time, just as `new EntryCollection(user, atomURL)` did. |
| **Transaction scope** | Collections use the shared `Weblogger` singleton's `flush()` and manager methods. No new transaction boundaries were introduced. The same persistence context is used. |
| **Cache invalidation** | `CacheManager.invalidate(website)` calls in `EntryCollection` are untouched — they do not flow through the interface. |

**Empirical proof:** The full test suite (`mvn clean test`) produces identical results — 158 tests run, 0 failures, 0 errors, 1 skipped — both before and after refactoring.

---

## 13. Architectural Impact

### Before

```
atomprotocol package (tightly coupled)
├── RollerAtomHandler  ←──┐
│   ├── creates EntryCollection ──→ calls RollerAtomHandler.canEdit()  (CYCLE)
│   └── creates MediaCollection ──→ calls RollerAtomHandler.canEdit()  (CYCLE)
├── EntryCollection (cannot be tested independently)
├── MediaCollection (cannot be tested independently)
└── RollerAtomService (independent — no cycle)
```

Every collection was structurally welded to the handler. Modifying `RollerAtomHandler`'s authorization interface risked breaking the collections, and modifying the collections required understanding the handler's authorization model. The package was a monolith in disguise.

### After

```
atomprotocol package (decoupled via interface)
├── AtomRequestContext (interface — the contract)
├── RollerAtomHandler implements AtomRequestContext
│   ├── creates EntryCollection(this, roller)
│   └── creates MediaCollection(this, roller)
├── EntryCollection depends on AtomRequestContext (not RollerAtomHandler)
├── MediaCollection depends on AtomRequestContext (not RollerAtomHandler)
└── RollerAtomService (unchanged)
```

Benefits:
- **Independent testability**: `EntryCollection` can be tested with a mock `AtomRequestContext` — no need to bootstrap `RollerAtomHandler` with its authentication infrastructure.
- **Interface as contract**: The authorization and throttling capabilities expected by collections are now documented in a named interface with Javadoc.
- **Safe evolution**: Adding new authorization checks (e.g., IP-based restrictions) requires only implementing a new `AtomRequestContext` method — the collections don't need to know about `RollerAtomHandler`'s internals.
- **Substitutability**: An alternative Atom handler (e.g., for testing, or for a different authentication scheme) can implement `AtomRequestContext` and be used with the same collection classes.

---

## 14. Future Extensibility Benefits

1. **Mock-based unit testing**: Test `EntryCollection.postEntry()` by creating a mock `AtomRequestContext` that returns a test user and always authorizes. No need for WSSE/OAuth/BASIC authentication setup.

2. **Alternative authentication**: A new `OAuth2AtomHandler` could implement `AtomRequestContext` and use the same `EntryCollection`/`MediaCollection` classes. The collections don't care *how* the user was authenticated — they only care that the context says the user is authorized.

3. **Authorization decoration**: A `LoggingAtomRequestContext` wrapper could log all authorization decisions without modifying any collection code.

4. **Throttle customization**: The `oneSecondThrottle()` method is now overridable (non-static). A testing context could implement it as a no-op for faster test execution.

---

## 15. Limitations and Tradeoffs

| Limitation | Description | Why Acceptable |
|------------|-------------|----------------|
| **Propagated change to MediaCollection** | MediaCollection was modified even though only the EntryCollection cycle was targeted in the plan | Necessary: removing `static` from `RollerAtomHandler`'s methods would break `MediaCollection`'s compilation. Both collections follow the identical pattern, and both benefit equally. The propagation is confined to the same package. |
| **One additional method dispatch** | Calls to `context.canEdit(...)` now go through a virtual dispatch table instead of a static call | Virtual dispatch adds ~1 nanosecond per call. In a web application that performs database queries and network I/O per request, this is undetectable. |
| **Interface adds one new type** | `AtomRequestContext.java` is a new file | A 77-line interface is a minimal addition. It documents a contract that was previously implicit (scattered across static method calls). |
| **Pre-existing `WebloggerFactory.getWeblogger()` calls remain** | `MediaCollection` still calls `WebloggerFactory.getWeblogger()` directly in two method bodies (lines 105, 216) | These are pre-existing direct singleton lookups unrelated to the cycle. Changing them would be a separate cleanup, not a cycle break. |
